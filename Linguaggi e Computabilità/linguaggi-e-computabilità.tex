
\documentclass[a4paper,12pt, oneside]{book}

%\usepackage{fullpage}
\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphics}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amstext}
\usepackage{engrec}
\usepackage{rotating}
\usepackage[safe,extra]{tipa}
\usepackage{showkeys}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{microtype}
\usepackage{enumerate}
\usepackage{braket}
\usepackage{marginnote}
\usepackage{pgfplots}
\usepackage{cancel}
\usepackage{polynom}
\usepackage{booktabs}
\usepackage{enumitem}
\usepackage{framed}
\usepackage{pdfpages}
\usepackage{pgfplots}
\usepackage{fancyhdr}

\usepackage{varwidth,pst-tree,realscripts}
\usepackage{bidi}
\usetikzlibrary{automata,positioning}
\psset{showbbox=false,treemode=D,linewidth=0.3pt,treesep=2ex,levelsep=0.5cm}
\newcommand{\LFTw}[2]{%
\Tr[ref=#1]{\psframebox[linestyle=none,framesep=4pt]{%
\begin{varwidth}{15ex}\center #2\end{varwidth}}}}
\newcommand{\LFTr}[2]{\Tr[ref=#1]{\psframebox[linestyle=none,framesep=4pt]{#2}}}

\def\pstreehooki{\psset{thislevelsep=*0pt}}
\def\pstreehookiii{\psset{thislevelsep=*0pt}}
\def\pstreehookv{\psset{thislevelsep=*0pt}}

\pagestyle{fancy}
\fancyhead[LE,RO]{\slshape \rightmark}
\fancyhead[LO,RE]{\slshape \leftmark}
\fancyfoot[C]{\thepage}



\title{Linguaggi e Computabilità}
\author{UniShare\\\\Davide Cozzi\\\href{https://t.me/dlcgold}{@dlcgold}\\\\Gabriele De Rosa\\\href{https://t.me/derogab}{@derogab} \\\\Federica Di Lauro\\\href{https://t.me/f_dila}{@f\textunderscore dila}}
\date{}

\pgfplotsset{compat=1.13}
\begin{document}
\maketitle

\definecolor{shadecolor}{gray}{0.80}

\newtheorem{teorema}{Teorema}
\newtheorem{definizione}{Definizione}
\newtheorem{esempio}{Esempio}
\newtheorem{corollario}{Corollario}
\newtheorem{lemma}{Lemma}
\newtheorem{osservazione}{Osservazione}
\newtheorem{nota}{Nota}
\newtheorem{esercizio}{Esercizio}
\tableofcontents
\renewcommand{\chaptermark}[1]{%
\markboth{\chaptername
\ \thechapter.\ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection.\ #1}}

\chapter{Introduzione}
\textbf{Questi appunti sono presi a lezione. Per quanto sia stata fatta una revisione è altamente probabile (praticamente certo) che possano contenere errori, sia di stampa che di vero e proprio contenuto. Per eventuali proposte di correzione effettuare una pull request. Link: } \url{https://github.com/dlcgold/Appunti}.\\
\textbf{Grazie mille e buono studio!}
\section{Definizioni}
\begin{itemize}
\item un \textbf{linguaggio }è un insieme di stringhe che può essere generato mediante un dato meccanismo con delle date caratteristiche; un linguaggio può essere riconosciuto, ovvero dando in input una stringa un meccanismo può dirmi se appartiene o meno ad un linguaggio. I meccanismi che generano linguaggi si chiamano \textit{grammatiche}, quelli che li riconoscono \textit{automi}. I linguaggi formali fanno parte dell'informatica teorica \textit{(TCS)}
\item si definisce \textbf{alfabeto} come un insieme finito e non vuoto di simbolo (come per esempio il nostro alfabeto o le cifre da 0 a 9). Solitamente si indica con $\Sigma$ o $\Gamma$
\item si definisce \textbf{stringa} come una sequenza finita di simboli (come per esempio una parola o una sequenza numerica). La stringa vuota è una sequenza di 0 simboli, e si indica con $\varepsilon$ o $\lambda$
\item si definisce \textbf{lunghezza di una stringa} il numero di simboli che la compone (ovviamente contando ogni molteplicità). Se si ha $w\in \Sigma^*$ è una stringa $w$ con elementi da $\Sigma^*$ (insieme di tutte le stringhe di tutte le lunghezze possibili fatte da $\Sigma$), allora $|w|$ è la lunghezza di $w$, inoltre $|\varepsilon|=0$.
\item si definisce \textbf{potenza di un alfabeto} $\Sigma^k$ come l'insieme di tutte le sequenze (espressi come stringhe e non simboli) di lunghezza $k\in\mathbb{N},\, k>0$ ottenibili da quell'alfabeto (se $\Sigma^2$ si avranno tutte le sequenza di 2 elementi etc...). Se ho $k=1$ si ha $\Sigma^1\neq \Sigma$ in quanto ora ho stringhe e non simboli. Se ho $k=0$ ho $\Sigma^0=\varepsilon$. Dato $k$ ho $|\Sigma|$ che è la cardinalità dell'insieme $\Sigma$ (e non la sua lunghezza come nel caso delle stringhe); sia $w\in\Sigma^k=a_1,a_2,...,a_k,\,a_i\in\Sigma$ e $|\Sigma|=q$ ora: $$|\Sigma^k|=q^k$$
\item si definisce $\Sigma^*$ come\textbf{ chiusura di Kleene} che è l'unione infinita di $\Sigma^k$ ovvero $$\Sigma*=\Sigma^0\cup \Sigma^1\cup...\cup \Sigma^k$$
\item si ha che $\Sigma^+$ è l'unione per $k\geq 1$ di $\Sigma^k$ ovvero:
$$\Sigma+=\Sigma^1\cup \Sigma^2\cup...\cup \Sigma^k= \Sigma^*-\Sigma^0$$
per esempio, per l'insieme $\{0,1\}$ si ha:
$$\Sigma^*=\{\varepsilon,0,1,00,01,10,100,000,...\}$$
\item quindi un \textbf{linguaggio} \textit{L} è un insieme di stringhe e:
$$L\subseteq \Sigma^*$$ 
si hanno sottoinsiemi particolari, come l'insieme vuoto, che resta però un linguaggio, il \textbf{linguaggio vuoto} e $\emptyset\in\Sigma^k,\,|\emptyset|=0$ che è diverso dal linguaggio che contiene la stringa vuota $|\varepsilon|=1$ (che conta come una stringa). Inoltre $\Sigma^*\subseteq \Sigma^*$ che ha lunghezza infinita. Posso concatenare due stringhe con un punto: $a\cdot b\cdot c=abc$ e $a\cdot \varepsilon=a$. Ovviamente la stringa concatenata è lunga come la somma delle lunghezze delle stringhe che la compongono. Vediamo qualche esempio di linguaggio:
\begin{itemize}
\item il linguaggio di tutte le stringhe che consistono in $n$ 0 seguiti da $n$ 1:
$$\{\varepsilon,01,0011,000111,...\}$$
\item l'insieme delle stringhe con un uguale numero di 0 e di 1:
$$\{\varepsilon,01,10.0011,0101.1001,..\}$$
\item l'insieme dei numeri binari il cui valore è un numero primo:
$$\{\varepsilon,10 , 11, 101, 111,1011,...\}$$
\item $\Sigma^*$ è un linguaggio per ogni alfabeto $\Sigma$
\item $\emptyset$, il linguaggio vuoto, e $\{\varepsilon\}$ sono un linguaggio rispetto a qualunque alfabeto
\end{itemize}
\end{itemize}
Prendiamo un alfabeto $\Sigma=\{0, 1\}$ con la sua chiusura di Kleen $\Sigma=\{0, 1\}^*$. Quando si ha un input si può avere un problema di decisione, \textit{P}, che dia come output "si" o "no". Posso avere un problema di decisione (o \textit{membership}) su $w\in\Sigma=\{0, 1\}^*$, con \textit{w} stringa, che dia in output "si" o "no". Un linguaggio \textit{L} sarà:
$$L=\{w\in\{0, 1\}^*\,|\,\, P(w)=si$$
quindi si ha che:
$$\Sigma^*\backslash L=\{P(w)=no\}$$
Vediamo ora un esempio di \textit{Context Free Language (CFL)}, costruito a partire da una \textit{Context Free Grammar (CFG)}:
\begin{esempio}
Sia $\Sigma=\{0, 1\}$ e $L_{pal}="stringhe\,\, palindrome\,\, binarie"$.
Quindi, per esempio, $0110\in L,\,\, 11011\in L$ ma $10010\not\in L$. Si ha che $\varepsilon$, la stringa vuota, appartiene a $L$. Diamo una definizione ricorsiva:
\begin{itemize}
\item \textbf{base:} $\varepsilon,\, 0\,\ 1\in L_{pal}$
\item \textbf{passo:} se $w$ è palindroma allora $0w0$ è palindromo e $1w1$ è palindromo
\end{itemize}
una variabile generica $S$ può sottostare alle \textit{regole di produzione} di una certa grammatica. In questo caso si ha uno dei seguenti:
$$S\to\varepsilon,\, S\to 0,\, S\to 1,\, S\to 0S0,\, S\to 1S1$$
\end{esempio}
Si ha che una grammatica $G$ è una quadrupla $G=(V,\,T,\,P,\,S)$ con:
\begin{itemize}
\item $V$ simboli variabili
\item $T$ simboli terminali, ovvero i simboli con cui si scrivono le stringhe alla fine
\item $P$ regole di produzione
\item $S$ variabile di partenza \textit{start}
\end{itemize}
riprendiamo l'esempio sopra:
\begin{esempio}
$$G_{pal}=(V=\{S\},\, T=\{0, 1\},\, P,\, S)$$
con:
$$P=\{S\to\varepsilon,\, S\to 0,\, S\to 1,\, S\to 0S0,\, S\to 1S1\}$$
Si può ora costruire un algoritmo per creare una stringa palindroma a partire dalla grammatica $G$:
$$\underbrace{S}_{\mbox{start}}\underbrace{\to}_{\mbox{applico una regola}} 1S1 \to 01S10\to \underbrace{01010}_{\mbox{sostituisco variabile}}$$

con $S,\, 1S1\,\, e\,\, 01S10$ che sono \textit{forme sentenziali}. Posso così ottenere tutte le possibili stringhe. Esiste anche una forma abbreviata:
$$S\to \varepsilon|o|1|0S0|1S1$$
Non si fanno sostituzioni in parallelo, prima una $S$ e poi un'altra
\end{esempio}
%aggiungi esempio parentesi
Si hanno 4 grammatiche formali, \textit{gerarchia di Chomsky}:
\begin{itemize}
\item \textbf{tipo 0:} non si hanno restrizioni sulle regole di produzione, $\alpha\to\beta$. Sono linguaggi ricorsivamente numerabili e sono rappresentati dalle \textit{macchine di Turing}, deterministiche o non deterministiche (la macchina di Turing è un automa)
\item \textbf{tipo 1:}  il lato destro della produzione ha lunghezza almeno uguale a quello sinistro. Sono grammatiche dipendenti dal contesto (\textit{contestuali}) e come automa hanno\textit{ la macchina di Turing che lavora in spazio lineare}:
$$\alpha_1A\alpha_2\to \alpha_1B\alpha_2$$
con $\alpha_1$ e $\alpha_2$ detti \textit{contesto} e $\alpha_1,\,\alpha_2,\, \beta\in (V\cup T)^*$
\item \textbf{tipo 2:} sono quelle libere dal contesto, context free. Come regola ha $A\to\beta$ con $A\in V$ e $\beta\in V\cup T)^*$ e come automa ha gli \textit{automi a pila non deterministici}
\item \textbf{tipo 3:} sono le grammatiche \textit{regolari}. Come regole ha $A\to\alpha B$ (o $A\to B\alpha$) e $A\to\alpha$  con $A,B\in V$ e $\alpha\in T$. Come automi ha gli \textit{automi a stato finito deterministici o non deterministici}
\end{itemize}
%aggiungi esercizio
\newpage
\begin{esempio}
Sia $G=(V,T,O,E)$, con $V=\{E,I\}$ e $T=\{a,b,0,1,(,),+,*\}$ 
quindi ho le seguenti regole, è di tipo 3:
\begin{enumerate}
\item $E\to I$
\item $E\to E+E$
\item $E\to E*E$
\item $E\to (E)$
\item $I\to a$
\item $I\to b$
\item $I\to Ia$
\item $I\to Ib$
\item $I\to I0$
\item $I\to I1$
\end{enumerate}
voglio ottenere $a*(a+b00)$ 
sostituisco sempre a destra (right most derivation)
$$E\to E*E\to E*(E)\to E*(E+E)\to E*(E+I)\to E+(E+I0)$$
$$\to R+(I+b00)\to E*(a+b00)\to I*(a+b00)\to a*(a+b00)$$

usiamo ora \textit{l'inferenza ricorsiva}:
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
passo & stringa ricorsiva & var & prod & passo stringa impiegata\\
1 & a & I & 5 & $\backslash$ \\
\hline
2 & b & I & 6 & $\backslash$ \\ 
\hline
3 & b0 & I & 9 & 2\\
\hline
4 & b00 & I & 9 & 3\\
\hline
5 & a & E & 1 & 1 \\
\hline
6 & b00 & E & 1 & 4\\
\hline
7 & a+b00 & E & 2 & 5,6\\
\hline
8 & (a+b00) & E & 4 & 7\\
\hline
9 &a*(a+b00) & E & 3 & 5, 8\\
\hline
\end{tabular}
\end{center}
\end{esempio}
definisco formalmente la derivazione $\to$:
\begin{definizione}
Prendo una grammatica $G=(V,T,P,S)$, grammatica CFG. Se $\alpha A \beta$ è una stringa tale che $\alpha,\beta\in (V\cup T)^*$, appartiene sia a variabili che terminali. Sia $A\in V$ e sia $a\to \gamma$ una produzione di $G$. Allora 
scriviamo:
$$\alpha A \beta \to \alpha\gamma\beta$$
con $\gamma\in (V\cup T)^*$.\\
Le sostituzioni si fanno indipendentemente da $\alpha$ e $\beta$.
Questa è quindi la definizione di derivazione.
\end{definizione}
\begin{definizione}
Definisco il simbolo $\to _*$, ovvero il simbolo di \textit{derivazioni in 0 o più passi}. Può essere definito in modo ricorsivo. Per induzione sul numero di passi.
\begin{itemize}
\item la base dice che  $\forall \alpha\in (V\cup T)^*,\, \alpha\to * \,\alpha$
\item il passo è: se $\alpha\to_G * \,\beta $ e $ \beta \to_G * \,\gamma$ allora $\alpha\to * \,\gamma$
\end{itemize}
Si può anche dire che $\alpha\to_G *\, \beta$ sse esiste una sequenza di stringhe $\gamma_1,...,\gamma_n$ con $n\geq 1$ tale che $\alpha=\gamma_1$, $\beta=\gamma_n$ e $\forall i,\, 1<i<n-1$ si ha che $\gamma_1\to \gamma_{i+1}$
la derivazione in 0 o più passi è la chiusura transitiva della derivazione
\end{definizione}
\begin{definizione}
avendo ora definito questi simboli possiamo definire una forma sentenziale. Infatti è una stringa $\alpha$ tale che:
$$\forall \alpha\in (V\cup T)^* \mbox{ tale che }S\to_G *\, \alpha$$
\end{definizione}
\begin{definizione}
data $G=(V,T,P,S)$ si ha che $L(G)=\{w\in T^* |\, S\to_G *\, w\}$ ovvero composto da stringhe terminali che sono derivabili o 0 o più passi.
\end{definizione}
\begin{esempio}
formare una grammatica CFG per il linguaggio:
$$L=\{0^n 1^n| n\geq 1\}=\{01, 0011, 000111,...\}$$
con $x^n$ intendo una concatenazione di $n$ volte $x$ (che nel nostro caso sono 0 e 1).\\
posso scrivere:
$$0^n 1^n =00^{n-1} 1^{n-1}1$$
il nostro caso base sarà la stringa $01$, Poi si ha:
$G=(V,T,P,S)$, $T=\{0,1\}$, $V=\{S\}$, il caso base $S\to 01$  e $S\to 0S1$
il caso passo è quindi: se $w= 0^{n-1}1^{n-1}\in L$ allora $0w1\in L$.\\
Ora voglio dimostare che $000111\in L$, ovvero $S\to*\, 000111$:\\
$$S\to\, 0S1 \to 00S11\to 000S111$$
\end{esempio}
\begin{teorema}
data la grammatica $G=\{V,T,P,S)$ CFG e $\alpha\in (V\cup T)^*$. Si ha che vale $S\to*\, \alpha$ sse $S\to_{lm}*\, \alpha$ sse $S\to_{rm}*\, \alpha$. Con $\to_{lm}*$ simbolo di \textit{left most derivation }e $\to_{rm}*$ simbolo di \textit{right most derivation}
\end{teorema}
\begin{esempio}
formare una grammatica CFG per il linguaggio:
$$L=\{0^n 1^n| n\geq 0\}=\{\varepsilon, 01, 0011, 000111,...\}$$
stavolta abbiamo anche la stringa vuota. Il caso base stavolta è $S\to\varepsilon| \, 0S1$ 
\end{esempio}
\begin{esempio}
Fornisco una CFG per $L=\{a^n|n\geq 1\}=\{a, aa, aaa,...\}$.
La base è $a$ \\il passo è che se $a^{n-1}\in L$ allora $a^{n-1}a\in L$ ( o che $aa^{n-1}\in L$).\\
Si ha la grammatica $G=\{V,T,P,S)$, $V=\{S\}$, $T=\{a\}$ e si hanno $S\to a|\,Sa$ (o  $S\to a|\,aS$). Dimostro che $a^3\in L$.
$$S\to Sa \to Saa\to aaa$$
oppure 
$$S\to aS\to aaS\to aaa$$
\end{esempio}
\begin{esempio}
trovo una CFG per $L=\{(ab)^n|n\geq 1\}=\{ab, abab, ababab,...\}$\\
La base è $ab$ \\il passo è che se $(ab)^{n-1}\in L$ allora $(ab)^{n-1}ab\in L$.\\
Si ha la grammatica $G=\{V,T,P,S)$, $V=\{S\}$, $T=\{a,b\}$ (anche se in realtà $T=\{ab\}$) e si hanno $S\to ab|\,Aab$. Poi dimostro come l'esempio sopra
\end{esempio}
\begin{esempio}
trovo una CFG per $L=\{a^n c b^n|n\geq 1\}=acb,aacbb,aaacbbb,...\}$\\
Il caso base è $acb$ il passo è che se $a^{n-1}cb^{n-1}\in L$ allora $a^{n-1}cb^{n-1}acb\in L$ 
Si ha la grammatica $G=\{V,T,P,S)$, $V=\{S\}$, $T=\{a,b,c\}$ e si hanno $S\to aSb|acb$.\\
dimostro che $aaaacbbbbb\in L$:
$$S\to aSb\to aaSbb\to aaaaSbbb\to aaaacbbbb$$

provo a usare anche una grammatica regolare, con le regole $S\to aS|c$, $c\to cB$ e $B\to bB|b$;
$$S\to aS\to aaS\to aaC\to aacB\to aacb...$$
non si può dimostrare in quanto non si può imporre una regola adatta
\end{esempio}
\begin{esempio}
$L=\{a^n c b^{n-1}|n\geq 2\}$, con $a^n c b^{n-1}=a^{n-1}acb^{n-1}$. $S\to aSb|aacb$. Quindi:
$$S\to aSb\to aaaccbb\in L$$
\end{esempio}
\begin{esempio}
cerco CFG per $L=\{a^n c^k b^n|\,n,\,k>0\}$. $a$ e $b$ devono essere uguali, uso quindi una grammatica context free, mentre $c$ genera un linguaggio regolare.\\
Si ha la grammatica $G=\{V,T,P,S)$, $V=\{S,C\}$, $T=\{a,b,c\}$ e si hanno $S\to aSb|aCb$ e $C\to cC|c$. dimostro che $aaaccbbb\in L, n=3,\, k=2$:
$$S\to aSb \to aaSbb\to aaaCbbb\to aaacCbbb\to aaaccbbb$$
\end{esempio}
\begin{esempio}
scrivere CFG per $L=\{a^nb^nc^kb^k|\, n,\,k\geq 0\}
$
$$=\{w\in\{a,b,c,d\}^*|\,a^nb^nc^kb^k|\, n,\,k\geq 0\}$$
quindi L concatena due linguaggi $L1$ e $L2$, $X=\{a^nb^n\}$ e $Y=\{c^kd^k\}$: 
$$X\to aXb | \varepsilon$$
$$Y\to cYd | \varepsilon$$
$$S\to XY$$
voglio derivare $abcd$:
$$S\to XY \to XcYd\to aXbcYd\to aXbc\varepsilon d\to a\varepsilon bc\varepsilon d\to abcd$$
voglio derivare $cd$
$$S\to XY\to Y\to cYd\to cd$$
\end{esempio}
Quindi se ho $w\in L1, L2$, ovvero appartenente ad una concatenazione di linguaggi prima uso le regole di un linguaggio, poi dell'altro e infine ottengo il risultato finale.\\
\begin{esempio}
scrivere CFG per $L=\{a^nb^kc^kd^n|\, n>0,\, k\geq 0\}
$.
$$S\to aSd|\, aXd$$
$$X\to bXc| \varepsilon$$
derivo $aabcdd$:
$$S\to aSd\to aaXdd\to aabXcdd\to aabcdd$$
\end{esempio}
\begin{esempio}
scrivere CFG per $L=\{a^ncb^nc^mad^m|\, n>0,\, m\geq 1\}
$.
$$S\to XY$$
$$X\to aXb|c$$
$$Y\to cUd| cad$$
$$S\to XY\to cY\to ccad$$
\end{esempio}
\begin{esempio}
scrivere CFG per $L=\{a^{n+m}xc^nyd^m|\, n,\, m\geq 0\}
$. $a^{n+m}=a^na^m \mbox{ o } a^ma^n$. Si hanno 2 casi:
\begin{enumerate}
\item $L=\{a^na^m xc^nyd^m|\, n,\, m\geq 0\}
$
\item $L=\{a^ma^n xc^nyd^m|\, n,\, m\geq 0\}
$
\end{enumerate}
ma solo  $L=\{a^ma^n xc^nyd^m|\, n,\, m\geq 0\}
$ può generare una CFG (dove non si possono fare incroci, solo concatenazioni e inclusioni/innesti). 
$$S\to aSd| Y$$
$$Y\to Xy$$
$$X\to aXc|x$$ 
si può fare in 2:
$$S\to aSd| Xy$$
$$X\to aXc|x$$ 
derivo con $m=n=1$, $aaxcyd$:
$$S\to aSd\to aXyd\to aaXcyd\to aaxcyd$$
\end{esempio}
\begin{esempio}
scrivere CFG per $L=\{a^nb^m|\, n\geq m \geq 0\}
$.$$L=\{\varepsilon, a, ab, aa, aab, aabb, aaa, aaab, aaabb, aaabbb,...\}$$
Se $n\geq m$ allora $\exists k\geq 0 \to n=m+k$. Quindi:
$$l=\{a^{m+k}b^m|m,k\geq0\}$$ si può scrivere in 2 modi:
\begin{enumerate}
\item $l=\{a^ma^kb^m|m,k\geq0\}$ quindi con innesto
\item $l=\{a^ka^mb^m|m,k\geq0\}$quindi con concatenazione
\end{enumerate}
entrambi possibili per una CFG:
\begin{enumerate}
\item 
$$S\to XY$$
$$X\to aX|\varepsilon \mbox{ si può anche scrivere } X\to Xa|\varepsilon$$
$$Y\to aYb|\varepsilon$$ 
oppure 
$$S\to aS|X$$
$$X\to aXb| \varepsilon$$
\item 
$$S\to aSb|\varepsilon$$
$$X\to aX|\varepsilon$$
\end{enumerate}
\end{esempio}
\begin{esempio}
scrivere CFG per $L=\{a^nb^{m+n}c^h|\, m>h\geq0,\, n\geq0\}
$.\\
Se $n>h$ allora $\exists k \to n= h+k$, quindi:
$$L=\{a^nb^{m+h+k}c^h|\, m>h\geq0,\, n\geq0\}$$. ovvero:
$$L=\{a^nb^nb^kb^hc^h|\, m\geq 0, k>0, h\geq 0\}$$
si ha:
$$S\to XYZ$$
$$X\to aXb|\varepsilon$$
$$Y\to Yb|b$$
$$Z\to bZc|\varepsilon$$
si può anche fare:
$$S\to XY$$
$$X\to aXb|\varepsilon$$
$$Y\to bYc|Z$$
$$Z\to bZ|b$$
\end{esempio}
\begin{esempio}
scrivere CFG per $L=\{a^nb^mc^k|\, k>n+m,\, n,m\geq 0\}
$.\\
per $n=m=0,\, k=1$ avrò la stringa $c$.
se $k>n+m$ allora $\exists l>0\to k=n+m+l$ quindi:
$$L=\{a^nb^mc^{n+m+l}|\, l>0,\, n,m\geq 0\}
$$
$$=L=\{a^nb^mc^nc^mc^l|\, l>0,\, n,m\geq 0\}$$
sistemando:
$$=L=\{a^nb^mc^lc^mcnl|\, l>0,\, n,m\geq 0\}$$
quindi:
$$S\to aSc|X$$
$$X\to bXc|Y$$
$$Y\to cY|c$$
\end{esempio}
\newpage
\begin{esempio}
scrivere CFG per $L=\{a^nxc^{n+m}y^hz^kd^{m+h}|\, n,m,k,h\geq 0\}
$.\\
ovvero:
$$L=\{a^nxc^nc^my^hz^kd^hd^m|\, n,m,k,h\geq 0\}$$
quindi avrò:
$$S\to XY$$
$$X\to aXc|x$$
$$Y\to cYd|W$$
$$W\to yWd|X$$
$$Z\to zZ|\varepsilon$$
\end{esempio}
\begin{esempio}
vediamo un esempio di grammatica dipendente dal contesto:
$$L=\{a^nb^nc^n|\, n\geq 1\}$$
$G=\{V,T,P,S\}=\{(S,B,C,X)\}=\{(a,b,c),P,S\}$
ecco le regole di produzione (qui posso scambiare variabili a differenza delle context free):
\begin{enumerate}
\item $S\to aSBC$
\item $S\to aBC$
\item $CB\to XB$
\item $XB\to XC$
\item $XC\to BC$
\item $aB\to ab$
\item $bB\to bb$
\item $bC\to bc$
\item $cC\to cc$
\end{enumerate}
vediamo un esempio di derivazione:
per $n=1$ ho $abc$ ovvero:
$$S\to aBC\to abC\to abc$$
con $n=2$ ho $aabbcc$:
$S\to aSBC\to aaBCBC\to aaBXBC\to aaBXCC\to aaBBCC\to aabBCC\to aabbCC\to aabbcC\to aabbcc$\\
%vedere dimostrazione pag 14 soligo
\end{esempio}
\newpage
\begin{esempio}
vediamo un esempio di grammatica dipendente dal contesto:
$$L=\{a^nb^mc^nd^m|\, n,m\geq 1\}$$
Si ha:
$$G=(\{S,X,C,D,Z\},\{a,b,c,d\},P,S)$$
con le seguenti regole di produzione:
\begin{itemize}
\item $S\to aSc|\, aXc$
\item $X\to bXD|\, bD$
\item $DC\to CD$
\item $DC\to DZ$
\item $DZ\to CZ$
\item $XZ\to CD$
\item $bC\to bc$
\item $cC\to cc$
\item $cD\to cd$
\item $dD\to dd$
\end{itemize}
provo a derivare $aabbbccddd$ quindi con $n=2,\,m=3$:\\
$$S\to aSC\to aaXCC\to aabXDCC\to aabbXDDCC\to $$
$$aabbbDDDCC\to aabbbCCDDD\to aabbbccddd$$
\end{esempio}
\begin{esempio}
Sia $L=\{w\in\{a,b\}^*|\, \mbox{ w contiene lo stesso numero di a e b}\}$:
$$S\to aSbS|\,bSaS|\, \varepsilon$$
dimostro per induzione che è corretto:
\begin{itemize}
\item \textbf{caso base:} $|w|=0\to w=\varepsilon$
\item \textbf{caso passo:} si supponga che $G$ produca tutte le stringhe (di lunghezza $<$ di $n$) di $\{a,b\}^*$ con lo stesso numero di \textit{a} e \textit{b} e dimostro che produce anche quelle di lunghezza $n$, sia:
$$w\in \{a,b\}^* \mid\, |w|=n \mbox{ con\textit{ a} e \textit{b} in egual numero, }m(a)=m(b) \mbox{ con m() che indica il numero di caratteri}$$
quindi si ha che:
$$w=aw_1bw_2\mbox{ o } w=bw_1aw_2$$
sia.
$$k_1=m(a)\in w_1=m(b)\in w_1$$
$$k_2=m(a)\in w_2=m(b)\in w_2$$
allora:
$$k_1+k_2+1=m(a)\in w= m(b)\in W$$
sapendo che $|w_1|<n$ e $|w_2|<n$ allora $w_1$ e $w_2$ sono egnerati da G per ipotesi induttiva
\end{itemize}
\end{esempio}
\subsection{Alberi Sintatici}
\begin{definizione}
Data una grammatica CFG, $G=\{V,T,P,S\}$ un \textbf{albero sintattico} per $G$ soddisfa le seguenti condizioni:
\begin{itemize}
\item ogni nodo interno è etichettato con una variabile
\item ogni foglia è anch'essa etichettata con una variabile o col simbolo di terminale T o con la stringa vuota $\varepsilon$ (in questo caso la foglia è l'unico figlio del padre)
\item se un nodo interno è etichettato con A i suoi figli saranno etichettati con X1, ..., Xk e $A\to  X1, ..., Xk$ sarà una produzione di $G$. Se un Xi è $\varepsilon$ sarà l'unica figlio e $A\to \varepsilon$ sarà comunque una produzione di $G$
\end{itemize}
La concatenazione in ordine delle foglie viene detto \textbf{prodotto dell'albero}
\end{definizione}
\newpage
\begin{esempio}
Usiamo l'esempio delle stringhe palindrome:
$$P\to 0P0|\,1P1|\varepsilon$$
sia il seguente albero sintatico:
\begin{center}
\psframebox[linestyle=none,framesep=10pt]{%
\pstree{\LFTw{t}{\fontspec{Noto Sans}[Script=Latin]P}}{\pstree{\Tp[edge=none]}{%
  \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]0}
  \pstree{\LFTw{t}{\fontspec{Noto Sans}[Script=Latin]P}}{\pstree{\Tp[edge=none]}{%
    \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]1}
    \pstree{\LFTw{t}{\fontspec{Noto Sans}[Script=Latin]P}}{\pstree{\Tp[edge=none]}{%
      \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]$\varepsilon$}}}
    \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]1}}}
  \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]0}}}}
\end{center}
\end{esempio}
\begin{esempio}
Si ha:
$$E\to I|\, E+E|\, E*E|\, (E)$$
$$I\to a|\,b|\,Ia|\,Ib|\,I0|\,I1$$
un albero sintattico per $a*(a+b00)$ può essere:
\begin{center}

\psframebox[linestyle=none,framesep=10pt]{%
\pstree{\LFTw{t}{\fontspec{Noto Sans}[Script=Latin]E}}{\pstree{\Tp[edge=none]}{%
  \pstree{\LFTw{t}{\fontspec{Noto Sans}[Script=Latin]E}}{\pstree{\Tp[edge=none]}{%
    \pstree{\LFTw{t}{\fontspec{Noto Sans}[Script=Latin]I}}{\pstree{\Tp[edge=none]}{%
      \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]a}}}}}
  \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]*}
  \pstree{\LFTw{t}{\fontspec{Noto Sans}[Script=Latin]E}}{\pstree{\Tp[edge=none]}{%
    \LFTw{t}{\fontspec{Noto Sans}[Script=Latin](}
    \pstree{\LFTw{t}{\fontspec{Noto Sans}[Script=Latin]E}}{\pstree{\Tp[edge=none]}{%
      \pstree{\LFTw{t}{\fontspec{Noto Sans}[Script=Latin]E}}{\pstree{\Tp[edge=none]}{%
        \pstree{\LFTw{t}{\fontspec{Noto Sans}[Script=Latin]I}}{\pstree{\Tp[edge=none]}{%
          \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]a}}}}}
      \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]+}
      \pstree{\LFTw{t}{\fontspec{Noto Sans}[Script=Latin]E}}{\pstree{\Tp[edge=none]}{%
        \pstree{\LFTw{t}{\fontspec{Noto Sans}[Script=Latin]I}}{\pstree{\Tp[edge=none]}{%
          \pstree{\LFTw{t}{\fontspec{Noto Sans}[Script=Latin]I}}{\pstree{\Tp[edge=none]}{%
            \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]b}}}
          \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]0}}}
        \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]0}}}}}
    \LFTw{t}{\fontspec{Noto Sans}[Script=Latin])}}}}}}
\end{center}
\end{esempio}
\newpage
Data una CFG si ha che i seguenti cinque enunciati si equivalgono:
\begin{enumerate}
\item la procedura di inferenza ricorsiva stailisce che una stringa $w$ di simboli terminali appartiene al linguaggio $L(A)$ con $A$ variabile
\item $A\to ^*w$
\item $A\to^*_{lm}w$
\item $A\to^*_{rm}w$
\item esiste un albero sintattico con radice $A$ e prodotto $w$
\end{enumerate}
queste 5 proposizioni si implicano l'uni l'altra:
\begin{center}
\begin{tikzpicture}
    \node (top) at (0,0) {5};
 	\node (a) at(-1,-0.5) {3};
 	\node (b) at(0,-1) {4};
 	\node (c) at(-2.0,-1.85) {2};
 	\node (d) at(1.5,-2) {1};
    \draw [->] (top) -- (a);
    \draw [->] (top) -- (b);
    \draw [->] (a) -- (c);
    \draw [->] (b) -- (c);
    \draw [->] (c) -- (d);
    \draw [->] (d) -- (top);
\end{tikzpicture}
\end{center}
vediamo qualche dimostrazione di implicazione tra queste proposizioni:
\begin{proof}[da 1 a 5]
si procede per induzione:
\begin{itemize}
\item \textbf{caso base:} ho un livello solo (una sola riga), $\exists A\to w$:
$$\overset{A}{\overset{\triangle}w}$$
\item \textbf{caso passo:} suppongo vero per un numero di righe $\leq n$, lo dimsotro per $n+1$ righe:
$$A\to X_1,X_2,...,X_k$$
$$w=w_1,w_2,...,w_k$$
ovvero, in meno di $n+1$ livelli:
\begin{center}

\psframebox[linestyle=none,framesep=10pt]{%
\pstree{\LFTw{t}{\fontspec{Noto Sans}[Script=Latin]A}}{\pstree{\Tp[edge=none]}{%
  \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]$\overset{X_1}{\overset{\triangle}w_1}$}
  \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]$\overset{X_2}{\overset{\triangle}w_2}$}
  \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]$\vdots$}
  \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]$\overset{X_k}{\overset{\triangle}w_k}$}}}}
\end{center}
\end{itemize}
\end{proof}
\begin{proof}[da 5 a 3]
procedo per induzione:
\begin{itemize}
\item \textbf{caso base (n=1): }$\exists A\to w\mbox{ quindi } A\to_{lm}w$, come prima si ha un solo livello:
$$\overset{A}{\overset{\triangle}w}$$
\item \textbf{caso passo: }suppongo che la proprierà valga per ogni albero di profondità minore uguale a $n$, dimostro che valga per gli alberi profondi $n+1$:
$$A\to X_1,X_2,...,X_k$$
$$w=w_1,w_2,...,w_k$$
ovvero, in meno di $n+1$ livelli:
\begin{center}

\psframebox[linestyle=none,framesep=10pt]{%
\pstree{\LFTw{t}{\fontspec{Noto Sans}[Script=Latin]A}}{\pstree{\Tp[edge=none]}{%
  \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]$\overset{X_1}{\overset{\triangle}w_1}$}
  \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]$\overset{X_2}{\overset{\triangle}w_2}$}
  \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]$\vdots$}
  \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]$\overset{X_k}{\overset{\triangle}w_k}$}}}}
\end{center}
$$A\to_{lm} X_1,X_2,...,X_k$$
$$x_1\to^*_{lm}w_1 \mbox{ per ipotesi induttiva si ha un albero al più di n livelli}$$
quindi:
$$A\to_{lm}X_1,...,X_k\to^*_{lm}w_1,X_2,...,X_k\to^*_{lm}...\to^*_{lm}w_1,...,w_k=w$$
\end{itemize}
\begin{esempio}
$$E\to I\to Ib\to ab$$
$$\alpha E\beta\to\alpha I\beta\to \alpha Ib\beta\to \alpha ab\beta,\,\,\,\alpha,\beta\in(V\cup T)^*$$
\end{esempio}
\end{proof}
\begin{esempio}
Mostro l'esistenza di una derivazione sinistra dell'albero sintattico di $a*(a+b00)$:
$$E\to^*_{lm}E*E\to^*_{lm}I*E\to^*_{lm}a*E\to^*_{lm}a*(E)\to^*_{lm}a*(E+E)\to^*_{lm}$$
$$a*(I+E)\to^*_{lm}a*(a+E)\to^*_{lm}a*(a+I)\to^*_{lm}a+(a+I0)\to^*_{lm}a*(a+I00)\to^*_{lm}a*(a+b00)$$
\end{esempio}
\subsection{Grammatiche ambigue}
\begin{definizione}
Una grammatica è definita ambigua se esiste una stringa $w$ di terminali che ha più di un albero sintattico
\end{definizione}
\begin{esempio}
vediamo un esempio:
\begin{enumerate}
\item $E\to E+E\to E+E*E$
ovvero:
\begin{center}

\psframebox[linestyle=none,framesep=10pt]{%
\pstree{\LFTw{t}{\fontspec{Noto Sans}[Script=Latin]E}}{\pstree{\Tp[edge=none]}{%
  \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]E}
  \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]+}
  \pstree{\LFTw{t}{\fontspec{Noto Sans}[Script=Latin]E}}{\pstree{\Tp[edge=none]}{%
    \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]E}
    \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]*}
    \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]E}}}}}}
\end{center}
\item $E\to E*E\to E+E*E$
ovvero:
\begin{center}

\psframebox[linestyle=none,framesep=10pt]{%
\pstree{\LFTw{t}{\fontspec{Noto Sans}[Script=Latin]E}}{\pstree{\Tp[edge=none]}{%
  \pstree{\LFTw{t}{\fontspec{Noto Sans}[Script=Latin]E}}{\pstree{\Tp[edge=none]}{%
    \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]E}
    \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]+}
    \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]E}}}
  \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]*}
  \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]E}}}}
\end{center}
\end{enumerate}
si arriva a due stringhe uguali ma con alberi diversi. Introduciamo delle categorie sintatiche, dei vincoli alla produzione delle regole:
\begin{enumerate}
\item $E\to T|\, E+T$
\item $T\to F|\, T+F$
\item $F\to I|\, (E)$
\item $I\to a|\,b|\,Ia|,Ib|\,I0|\,I1$
\end{enumerate}
\end{esempio}
Possono esserci più derivazioni di una stringa ma l'importante è che non ci siano alberi sintattici diversi. Capire se una CFG è ambigua è un problema indecidibile
\begin{esempio}
vediamo un esempio:
$$S\to \varepsilon|\,SS|\, iS|\, iSeS$$
con S=statement, i=if e e=else. Considero due derivazioni:
\begin{enumerate}
\item $S\to iSeS\to iiSeS\to iie$:
\begin{center}

\psframebox[linestyle=none,framesep=10pt]{%
\pstree{\LFTw{t}{\fontspec{Noto Sans}[Script=Latin]S}}{\pstree{\Tp[edge=none]}{%
  \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]i}
  \pstree{\LFTw{t}{\fontspec{Noto Sans}[Script=Latin]S}}{\pstree{\Tp[edge=none]}{%
    \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]i}
    \pstree{\LFTw{t}{\fontspec{Noto Sans}[Script=Latin]S}}{\pstree{\Tp[edge=none]}{%
      \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]$\varepsilon$}}}}}
  \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]e}
  \pstree{\LFTw{t}{\fontspec{Noto Sans}[Script=Latin]S}}{\pstree{\Tp[edge=none]}{%
    \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]$\varepsilon$}}}}}}\end{center}
\item $S\to iS\to iiSeS\to iieS\to iie$:
\begin{center}

\psframebox[linestyle=none,framesep=10pt]{%
\pstree{\LFTw{t}{\fontspec{Noto Sans}[Script=Latin]S}}{\pstree{\Tp[edge=none]}{%
  \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]i}
  \pstree{\LFTw{t}{\fontspec{Noto Sans}[Script=Latin]S}}{\pstree{\Tp[edge=none]}{%
    \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]i}
    \pstree{\LFTw{t}{\fontspec{Noto Sans}[Script=Latin]S}}{\pstree{\Tp[edge=none]}{%
      \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]$\varepsilon$}}}
    \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]e}
    \pstree{\LFTw{t}{\fontspec{Noto Sans}[Script=Latin]S}}{\pstree{\Tp[edge=none]}{%
      \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]$\varepsilon$}}}}}}}}
\end{center}
\end{enumerate}
Si ha quindi una grammatica ambigua
\end{esempio}
\begin{teorema}
Per ogni CFG, con $G=(V, T, P, S)$, per ogni stringa $w$ di terminali si ha che $w$ ha due alberi sintattici distinti sse ha due derivazioni sinistre da S distinte.\\
Se la grammatica non è ambigua allora esiste un'unica derivazione sinistra da $S$
\end{teorema}
\subsubsection{Linguaggi inerentemente ambigui}
\begin{definizione}
Un linguaggio $L$ è inerentemente ambiguo se tutte le grammatiche CFG per tale linguaggio sono a loro volta ambigue
\end{definizione}
\begin{esempio}
Sia $L=\{a^nb^nc^md^m|\, n,m\geq 1\}\cup \{a^nbmnc^md^n|\, n,m\geq 1\}$\\
si ha quindi un CFL formato dall'unione di due CFL. $L$ è inerentemente ambiguo e generato dalla seguente grammatica:
\begin{itemize}
\item $S\to AB|\,C$
\item $A\to aAb|\,ab$
\item $B\to cBd|\, cd$
\item $C\to aCd|\, aDd$
\item $D\to bDc|\, bc$
\end{itemize}
si possono avere due derivazioni:
\begin{enumerate}
\item $S\to_{lm}AB\to_{lm} aAbB\to_{lm} aabbB\to_{lm}aabbcBd\to_{lm}aabbccdd$
\item $S\to_{lm} C\to_{lm} aCd\to_{lm}aaBdd\to_{lm}aabBcdd\to_{lm}aabbccdd$
\end{enumerate}
a generare problemi sono le stringhe con n=m perché possono essere prodotte in due modi diversi da entrambi i sottolinguaggi. Dato che l'intersezione tra i due sottolinguaggi non è buota si ha che $L$ è ambiguo
\end{esempio}
\subsection{Grammatiche Regolari}
Sono le grammatiche che generano i linguaggi regolari (quelli del terzo tipo) che sono casi particolari dei CFL.\\
Si ha la solita grammatica $G = (V, T, P, S)$ con però vincoli su $P$:
\begin{itemize}
\item $\varepsilon$ si può ottenere solo con $S\to \varepsilon$
\item le produzioni sono tutte lineari a destra ($A\to aA$ o $A\to a$) o a sinistra ($A\to Ba$ o $A\to a$)
\end{itemize}
\begin{esempio}
$I\to a|\,b|\,Ia|\,Ib|\,I0|\,I1$ è una grammatica con le produzioni lineari a sinistra.\\
Potremmo pensarlo a destra $I\to a|\,b|\,aI|\,bI|\,0I|\,1I$.\\
Vediamo esempi di produzione con queste grammatiche:
\begin{itemize}
\item con $I\to a|\,b|\,Ia|\,Ib|\,I0|\,I1$ possiamo derivare $ab01b0$:
$$I\to I0\to Ib0\to I1b0\to I01b0\to Ib01b0\to ab01b0$$
\item con $I\to a|\,b|\,aI|\,bI|\,0I|\,1I$ invece non riusciamo a generare nulla:
$$I\to 0I\to 0a$$
\end{itemize}
definisco quindi un'altra grammatica (con una nuova categoria sintattica):
$$I\to aJ|\, bJ$$
$$J\to a|\,b|\,aJ|\,bJ|\,0J|\,1J$$
che però non mi permette di terminare le stringhe con 0 e 1, la modifico ancora otterdendo:
$$I\to aJ|\, bJ$$
$$J\to a|\,b|\,aJ|\,bJ|\,0J|\,1J|\,0|\,1$$
e questo è il modo corretto per passare da lineare sinistra a lineare destra
\end{esempio}
\begin{esempio}
Sia $G=(\{S\},\{0,1\},P,S)$ con $S\to \varepsilon|\,0|\,1|\,0S|\,1S$. Si ha quindi:
$$L(G)=\{0,1\}^*$$
si hanno comunque due proposizioni ridondanti, riducendo trovo:
$$S\to \varepsilon|\, 0S|\,1S$$
con solo produzioni lineari a destra. Con produzioni lineari a sinistra ottengo:
$$S\to \varepsilon|\, S0|\,S1$$
\end{esempio}
\begin{esempio}
Trovo una grammatica lineare destra e una sinistra per $L=\{a^nb^m|\,n,m\geq 0\}$:
\begin{itemize}
\item \textbf{lineare a destra:} si ha $G=(\{S,B\},\{a,b\},P,S)$ e quindi:
$$S\to \varepsilon|\,aS|\,bB$$
$$B\to bB|\,b$$
ma non si possono generare stringhe di sole $b$, infatti:
$$S\to aS\to abB\to abbB\to abbb$$
ma aggiungere $\varepsilon$ a B \textbf{non è lecito}. posso però produrre la stessa stringa da due derivazioni diverse:
$$S\to \varepsilon|\,aS|\,bB|\,b$$
$$B\to bB|\,b$$
che risulta quindi la nostra lineare a destra
\item \textbf{lineare a sinistra:} si ha $G=(\{S,A\},\{a,b\},P,S)$ e quindi:
$$S\to \varepsilon|\,Sb|\,Ab|\,a$$
$$A\to Aa|\,a$$
\end{itemize}
\end{esempio}
\begin{esempio}
Trovo una grammatica lineare destra e una sinistra per $L=\{ab^ncd^me|\,n\geq 0\,,m> 0\}$:
\begin{itemize}
\item \textbf{lineare a destra:} si ha  si ha $G=(\{S,A,B,E\},\{a,b,c,d,e\},P,S)$ e quindi:
$$S\to aA$$
$$A\to bA|\,cB$$
$$B\to dB|\, dE$$
$$E\to e$$
\item \textbf{lineare a sinistra:} si ha  si ha $G=(\{S,X,Y,Z\},\{a,b,c,d,e\},P,S)$ e quindi:
$$S\to Xe$$
$$A\to Xd|\,Yd$$
$$B\to Zc$$
$$E\to a|\,Zb$$
\end{itemize}
quindi se per esempio ho la stringa "ciao" si ha:
\begin{itemize}
\item \textbf{lineare a destra:}
$$S\to Ao$$
$$A\to Ba$$
$$B\to Ei$$
$$E\to c$$
\item \textbf{lineare a sinistra:} 
$$S\to cA$$
$$A\to iB$$
$$B\to aE$$
$$E\to o$$
\end{itemize}
\end{esempio}
\begin{esempio}
A partire da $G=(\{S,T\},\{0,1\},P,S)$ con:
$$S\to\varepsilon|\,0S|\,1T$$
$$T\to 0T|\,1S$$

trovo come è fatto $L(G)$:
$$L(G)=\{w\in\{0,1\}^*|\, w \mbox{ ha un numero di 1 pari}\}$$
\end{esempio}
\begin{esempio}
fornire una grammatica regolare a destra e sinistra per:
$$L=\{w\in\{0,1\}^*|\, w \mbox{ ha almeno uno 0 o almeno un 1}\}$$
Si ah che tutte le stringhe tranne quella vuota ciontengono uno 0 o un 1
quindi  $G=(\{S\},\{0,1\},P,S)$:
\begin{itemize}
\item \textbf{lineare a destra:}
$$S\to 0|\,1|\,0S|\,1S$$
\item \textbf{lineare a sinistra:} 
$$S\to 0|\,1|\,S0|\,S1$$
\end{itemize}
\end{esempio}
\subsection{Espressioni Regolari (Regex)}
le regex sono usate per la ricerca di un pattern in un testo o negli analizzatori lessicali. Una regex denota il linguaggio e non la grammatica. Si hanno le seguenti operazioni tra due linguaggi $L$ e $M$:
\begin{itemize}
\item \textbf{unione:} dati $L,\, M\in \Sigma^*$, l'unione $L\cup M$ è l'insieme delle stringhe che si trovano in entrambi i linguaggi o solo in uno dei due
\begin{esempio}
$$L=\{001,10,111\}$$
$$M=\{\varepsilon,001\}$$
$$L\cup M=\{\varepsilon,01,10,111,\varepsilon\}$$
\end{esempio}
si ha che:
$$L\cup M=M\cup L$$
\item \textbf{concatenazione:} dati $L,\, M\in \Sigma^*$, la concatenazione $L\cdot M$ (o $LM$) è lisieme di tutte le stringhe ottenibili concatenandone una di $L$ a una di $M$
\begin{esempio}
$$L=\{001,10,111\}$$
$$M=\{\varepsilon,001\}$$
$$L\cdot M=\{001,001001,10,...\}$$
\end{esempio}
si ha che:
$$L\cdot M\neq M\cdot L$$
\item si definiscono:
\begin{itemize}
\item $L\cdot L=L^2$, $L\ cdot L\cdot L=L^3$ etc...
\item $L^1=L$
\item $L^0=\{\varepsilon\}$
\end{itemize}
\item \textbf{chiusura di Kleene:} dato $L\subseteq \Sigma^*$ si ha che la chiusura di Kleen di $L$ è:
$$L^*=\underset{i\geq 0}{\cup}L^i$$
ricordando che $l^0=\varepsilon$
\begin{esempio}
Sia $L=\{0,11\}$, si ha:
$$L^0=\varepsilon$$
$$L^1=L=\{0,11\}$$
$$L^2=L\cdot L=\{00,011,110,1111\}$$
$$L^3=L\cdot L\cdot L=L^2\cdot L=\{000,0110,1100,11110,0011,01111,11011,111111\}$$
\end{esempio}
vediamo dei casi particolari:
\begin{itemize}
\item $L=\{0^n|\,n\geq 0\}$ implica $|L|=\infty$ e quindi, essendo $L^i=L,\, i\geq 1$ e quindi $|L^i|=\infty$, $|L^*|=\infty$. Si ha quindi:
$$L^*=L^0\cup L^1\cup ... \cup L^i=L$$
\item $L=\emptyset$ implica $L^0=\{\varepsilon\}$, $L^2=L\cdot L=\emptyset$ e così via per ogni concatenazione di $L$. Si ha quindi:
$$L^*=L^0=\{\varepsilon\}$$
\item $L=\{\varepsilon\}$ implica $L^0=\{\varepsilon\}=L=L^1=L^2=...$, si ha quindi:
$$L^*=\{\varepsilon\}=L$$
\end{itemize}
L'insieme vuoto e l'insieme contenente la stringa vuota hanno le uniche chiusure di kleene finite
\end{itemize}
\begin{definizione}
Si riporta la definizione ricorsiva di un'espressione regolare:
\begin{itemize}
\item \textbf{casi base:} si hanno tre casi base:
\begin{enumerate}
\item $\varepsilon$ e $\emptyset$ sono espressioni regolari
\item se $a\in \Sigma$ $a$ è un'esprssione regolare, $L(a)=\{a\}$
\item le variabili che rappresentano linguaggi regolari sono espressioni regolari, $L(L)=L$
\end{enumerate}
\item \textbf{casi passo:} si hanno i 4 casi passo:
\begin{enumerate}
\item \textbf{unione:} se $E$ e $F$ sono espressioni regolari allora anche $E+F=E\cup F$ è un'espressione regolare e si ha:
$$L(E+F)=L(E)\cup L(F)$$
\item \textbf{concatenazione:} se $E$ e $F$ sono espressioni regolari allora anche $EF=E\cdot F$ è un'espressione regolare e si ha:
$$L(EF)=L(E)\cdot L(F)$$
\item \textbf{chiusura:} se $E$ è un'espressione regolare allora $E^*$ è un'espressione regolare e si h:
$$L(E^*)=(L(E))^*$$
\item \textbf{parentesi:} se $E$è un'espressione regolare allora $(E)$ è un'espressione regolare e si ha:
$$L((E))=L(E)$$
\end{enumerate}
\end{itemize}
\newpage
\begin{esempio}
trovo regex per l'insieme di stringhe in $\{0,1\}^*$ che consistono in 0 e 1 alternati:\\
$$01\to \{01\}$$
$$(01)^*\to \{\varepsilon, 01, 0101,010101,...\}$$
$$(01)^*+(10)^*\to\{\varepsilon, 01,10,0101,1010,...\}$$
ma posso volere diverse quantità di 0 e 1, sempre mantenendo l'alternanza, metto o uno 0 o un 1 davanti a quanto ottenuto appena sopra:
$$(01)^*+(10)^*+0(10)^*+1(01)^*\to \{\varepsilon,01,10,010,101,...\}$$
non è comunque l'unica soluzione, si può avere:
$$(\varepsilon+1)(01)^*(\varepsilon+0)\to \{\varepsilon,01,10,010,101,...\}$$
oppure ancora:
$$(\varepsilon+0)(10)^*(\varepsilon+1)$$
\end{esempio}
\end{definizione}
Si ha una precedenza degli operatori, in ordine di precedenza (si valuta da sinistra a destra):
\begin{enumerate}
\item chiusura di Kleene *
\item concatenazione $\cdot$, che è associativo ($(E\cdot F)\cdot G=E\cdot (F\cdot G)$) ma non è commutativo ($E\cdot F\neq F\cdot E$)
\item unione + che è associativa ($(E+ F)+ G=E+ (F+ G)$) ed è commutativo ($E+F= F+ E$)
\item infine le parentesi
\end{enumerate}
si hanno anche delle proprietà algebriche:
\begin{itemize}
\item due espressioni regolari sono equivalenti se denotano le stesso linguaggio
\item due espressioni regolari con variaboli sono equivalenti se lo sono $\forall$ assegnamento alle variabili
\item l'unione è commutativa e associativa, la concatenazione è solo associativa
\item si definiscono:
\begin{itemize}
\item \textbf{identità:} ovvero un valore unito all'identità è pari a se stesso (elemento neutro della somma $0+x=x+0=x$). $\emptyset$ è identità per l'unione ($\emptyset+L=L+\emptyset=L$), $\{\varepsilon\}$ è identità per la concatenazione ($\varepsilon L=L\varepsilon=L$)
\item \textbf{annichilitore:} ovvero un valore concatenato all'annichilatore da l'annichilitore (l'elemento nullo del prodotto $0x=x0=0$).  $\emptyset$ è l'annichilitore per la concatenazione ($\emptyset L=L\emptyset=\emptyset$)
\end{itemize}
\item \textbf{distributività:} dell'unione rispetto alla concatenazione (che non è commutativa):
\begin{itemize}
\item \textbf{distributività sinistra:} $L(M+N)=LM+LN$
\item \textbf{distributività destra:} $(M+N)L=ML+NL$
\end{itemize}
\item \textbf{idempotenza:} $L+L=L$
\item $(L^*)^*=L^*$
\item $\emptyset^*=\varepsilon$ infatti $L(\emptyset)=\{\varepsilon\}\cup L(\emptyset)\cup L(\emptyset)\cdot L(\emptyset)\cup...=\{\varepsilon\}\cup \emptyset\cup \emptyset...=\varepsilon$
\item $\varepsilon^*=\varepsilon$ infatti $L(\varepsilon^*)=\{\varepsilon\}\cup L(\varepsilon)\cup L(\varepsilon)=\{\varepsilon\}\cup \{\varepsilon\}\cup ...=\{\varepsilon\}=L(\varepsilon)$
\item $L^+=L\cdot L^*=L^*\cdot L$ (quindi con almeno un elemento che non sia la stringa vuota)
\item $L^*=l^++\varepsilon$  
\end{itemize}
\begin{esempio}
Ho $ER=(0+1)^*0^*(01)^*$:
\begin{itemize}
\item 001 fa parte del linguaggio? Si: $\varepsilon\cdot 0\cdot 01$
\item 1001 fa parte del linguaggio? Si: $1\cdot 0\cdot 01$
\item 0101 fa parte del linguaggio? Si: $\varepsilon\cdot\varepsilon \cdot 0101$
\item 0 fa parte del linguaggio? Si: $\varepsilon\cdot 0\cdot \varepsilon$
\item 10 fa parte del linguaggio? Si: $1\cdot 0\cdot \varepsilon$
\end{itemize}
$$L((0+1)^*)=(L(0+1))^*=(L(0)+L(1))^*=(\{0\}\cup \{1\})^*=(\{0,1\})^*=\{0,1\}^*$$
ovvero tutte le combinazioni di 0 e 1
\end{esempio}
Si ricorda che:
$$(0+1)^*\neq 0^*+1^*$$
\newpage
\begin{esempio}
ho $ER=((01)^*\cdot 10\cdot (0+1)^*)^*$
\begin{itemize}
\item 0101 fa parte del linguaggio? No
\item 01000 fa parte del linguaggio? No 
\item 01011 fa parte del linguaggio? No
\item 10111 fa parte del linguaggio? Si, $\varepsilon\cdot 10\cdot 111$
\item 101010 fa parte del linguaggio? Si, prendo $10\cdot 1010$
\item 101101 fa parte del linguaggio? Si, $\varepsilon\cdot 10\cdot 1$ due volte
\item 0101100011 fa parte del linguaggio? Si, $0101\cdot 10\cdot 0011$ (0011 lo posso prendere da $(0+1)^*$)
\end{itemize}
\end{esempio}
\begin{esempio}
ho $ER=((01)^*\cdot 10\cdot (0+1))^*$
\begin{itemize}
\item 0101 fa parte del linguaggio? No
\item 01000 fa parte del linguaggio? No 
\item 01011 fa parte del linguaggio? No
\item 10111 fa parte del linguaggio? No
\item 101010 fa parte del linguaggio? No
\item 101101 fa parte del linguaggio? Si, $\varepsilon\cdot 10\cdot 1$ due volte
\item 0101100011 fa parte del linguaggio? No
\end{itemize}
\end{esempio}
\begin{esempio}
Da $L\subseteq\{0,1\}|\mbox{ stringhe contenenti almeno una volta 01}$
quindi:
$$(0+1)^*01(0+1)^*$$
\end{esempio}
\begin{esempio}
ho $ER=(00^*1^*)^*$, quindi:
$$L=\{\varepsilon,0,01,000,001,010,011\}=\{\varepsilon\}\cup\{w\in\{0,1\}^* |\mbox{ w che inizia con 0}\}$$
\end{esempio}
\begin{esempio}
ho $ER=a(a+b)^*b$, quindi:
$$L=\{w\in\{a,b\}^*|\mbox{ w inizia con a e termina con b}\}$$
\end{esempio}
\begin{esempio}
ho $ER=(0^*1^*)^*000(0+1)^*$, quindi, sapendo che $\{0,1\}^*$ mi permette tutte le combinazioni che voglio come $(0+1)^*$:
$$L=\{w\in\{0,1\}^*|\mbox{ w come voglio con tre 0 consecutivi}\}$$
\end{esempio}
\begin{esempio}
ho $ER=a(a+b)^*c(a+b)^*c(a+b)^*b$, quindi:
$$L=\{w\in\{a,b,c\}^*|\mbox{ w inizia con a, termina con b  e contiene almeno due c, }$$
$$\mbox{eventualmente non adiacenti}\}$$
\end{esempio}
\begin{esempio}
Da $L\subseteq\{0,1\}|\mbox{ ogni 1 è seguito da 0, a meno che non sia l'ultimo carattere}$, ovvero 11 non compare
quindi:
$$(10+0)^*(\varepsilon+1)^*$$
\end{esempio}
\begin{esempio}
cerco ER per $L\subseteq\{0,1\}^*|\, \mbox{stringhe contenenti un numero pari di 1}$:
$$(0^*10^*1)^*0^*$$
oppure:
$$(0+10^*1)^*$$
\end{esempio}
\begin{esempio}
cerco ER per $L\subseteq\{0,1\}^*|\, \mbox{stringhe contenenti un numero dispari di 1}$:
$$(0^*10^*)^*0^*10^*$$
oppure:
$$(0+10^*1)^*10^*$$
\end{esempio}
\begin{esempio}
cerco ER per $L\subseteq\{0,1\}^*|\, \mbox{stringhe contenenti un numero divisibile per 3 di 0}$:
$$(1^*01^*01^*0)^*1^*$$
\end{esempio}
\begin{esempio}
cerco ER per $L\subseteq\{0,1\}^*|\, \mbox{stringhe contenenti al più una coppia di 1 consecutivi}$:
$$(10+0)^*(11+1+\varepsilon)(01+0)^*$$
\end{esempio}
\begin{esempio}
cerco ER per $L\subseteq\{a,b,c\}^*|\, \mbox{stringhe contenenti almeno una a e almeno una b}:$
$$c^*\left(a(a+c)^*b+b(b+c)^*a\right)(a+b+c)^*$$
\end{esempio}
\section{Automi}
\input{automi.tex}
\newpage
torniamo a dare bene qualche definizione per \^{$\delta$} in un DFA:
\begin{center}
\^{$\delta$}$:Q\times \Sigma^* \to Q$
\end{center}
con: $q\in Q,\,\,\, w\in \Sigma^*\,\,\,e\,\,\,$\^{$\delta$}$(p,w)=q$
\begin{itemize}
\item 
\textbf{caso base:} $w=\varepsilon\to |w|=0\to$\^{$\delta$}$(q,\varepsilon)=q$
\\
\textbf{caso passo:} $|w|\neq0\to w=ax$ con $a\in \Sigma,x\in \Sigma^*$:
\^{$\delta$}$(q,w)=$\^{$\delta$}$(q,ax)=$\^{$\delta$} $(\delta(q,a),x)$
\item 
\textbf{caso base:} $w=\varepsilon\to |w|=0\to \delta(q,w)=\delta(q,\varepsilon)=q$
\\
\textbf{caso passo:} $|w|\neq0\to w=xa$ con $a\in \Sigma,x\in \Sigma^*$:
\^{$\delta$}$(q,w)=$\^{$\delta$}$(q,xa)=$\^{$\delta$} $(\delta(q,x),a)$
\end{itemize}
in un NFA si ha:
\begin{itemize}
\item \textbf{caso base:}  \^{$\delta$}$(q,\varepsilon=\{q\},\,\,\forall q\in Q$
\item \textbf{caso passo:} posto $w=ax$ e \^{$\delta$}$(q,a)=\{p_1,...,p_n\`$ allora \^{$\delta$}$(q,w)=\cup$\^{$\delta$}$(p_i, x)0\{r_1,...,r_n\}$.\\
 \^{$\delta$}$(q,a)=p$\\
  \^{$\delta$}$(q,w)=$ \^{$\delta$}$(q,xa)=$ \^{$\delta$}$(p,x)=r$
\end{itemize}
oppure:
\begin{itemize}
\item \textbf{caso base:}  \^{$\delta$}$(q,\varepsilon)=\{q\},\,\forall q\in Q$
\item \textbf{caso passo:} posto $w=xa$ si ha  \^{$\delta$}$(q,q)=$ \^{$\delta$}$(q,xa)=\cup \delta(p,a)$ con  \^{$\delta$}$(q,x)=\{p_1,...,p_n\}$
\end{itemize}
Se ho un NFA $N=(Q_N, \Sigma, \delta_N, q_{0_N}, F_N)$ con $\delta_N: Q\times\Sigma^*\to 2^{Q_N}$ che accetta un lingiaggio $L$ posso ottenere un DFA $D=(Q_D, \Sigma, \delta_D, q_{0_D}, F_D)$ equivalente con $Q_D=2^{Q_N}$  e $q_{0_D}=\{q_{0_N}\}$ che accetta L.\\
$\forall S\subseteq Q_N$ e $\forall a\in \Sigma$ si ha:
$$F_D=\{S\subseteq Q_N\,|\, S\cap F_n\neq \emptyset\}$$
con $\delta_D(S,a)=\cup \delta_N(p,a)$
 Si ha che:
$$|Q_D|=|2^{Q_N}|=2^{|Q_N|}$$
partiamo con un esempio:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
gin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
   \node[state,initial] (q_0)   {$q_0$}; 
   \node[state] (q_1) [right=of q_0] {$q_1$}; 
   \node[state] (q_2) [right=of q_1] {$...$}; 
   \node[state] (q_3) [right=of q_2] {$q_{n-1}$}; 
   \node[state, accepting] (q_4) [right=of q_3] {$q_n$}; 
   \path[->] 
   (q_0) edge  node {1} (q_1)
         edge [loop above] node {0,1} ()
   (q_1) edge  node {0,1} (q_2)
   (q_2) edge node {0,1} (q_3)
   (q_3) edge node {0,1} (q_4);
\end{tikzpicture}
\end{center}
che definisce un $L\subseteq\{0,1\}^*$ tale che $w\in L$ sse n-simo elemento della fine è 1. Si ha:
$$|Q_N|=n+1\to |Q_D|=2^n$$
Si ha che dato un $\varepsilon$-NFA $E=(Q_E, \Sigma, \delta_E, q_{0_E}, F_E)$ che riconosce $L$ in un NFA $N=(Q_N, \Sigma, \delta_N, q_{0_N}, F_N)$ equivalenti con $Q_N=2^{Q_E}$ stati in $Q_E$ $\varepsilon$-close: \textit{ECLOSE(S)=S} e $q_N=ECLOSE(q_E)$:
$$F_N\{S\in Q_F,\,\, S\subseteq Q_E | S\cap F_E\neq \emptyset\}$$
quindi:
$$\forall a\in \Sigma \mbox{ e } \forall S=\{p_1,...,p_k\}, \forall S\in Q_F \mbox{ e } Q_E$$
$$\delta_F(S,a) \mbox{ si ottiene }\cup \delta_E(p_i,a)=\{r_1,..., r_n\}$$
$$\delta_N(S,a)=ECLOSE(\{r_1, ..., r_n\})$$
\newpage
\subsection{Da espressioni regolari a automi E-NFA}
\begin{itemize}
\item \textbf{caso base}:
\begin{enumerate}
\item se $R=\varepsilon$ ovvero $L(R)=\{\varepsilon\}$ allora:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
   \node[state,initial] (q_0)   {$q_0$}; 
   \node[state, accepting] (q_1) [right=of q_0] {$q_1$}; 
   \path[->]
   (q_0) edge node {$\varepsilon$} (q_1);
\end{tikzpicture}
\end{center}
\item se $R=\emptyset$ ovvero $L(R)=\emptyset$ allora:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
   \node[state,initial] (q_0)   {$q_0$}; 
   \node[state, accepting] (q_1) [right=of q_0] {$q_1$}; ;
\end{tikzpicture}
\end{center}
\item se $R=a$ ovvero $L(R)=\{a\}$ allora:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
   \node[state,initial] (q_0)   {$q_0$}; 
   \node[state, accepting] (q_1) [right=of q_0] {$q_1$};
   \path[->]
   (q_0) edge node {a} (q_1);
\end{tikzpicture}
\end{center}
\end{enumerate}
\item \textbf{caso passo:}
\begin{enumerate}
\item se $R=S+T$ quindi $L(R)=L(S)+L(T)$ allora:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
   \node[state,initial] (q_0)   {$q_0$}; 
   \node[state] (q_1) [above right =of q_0] {$q_1$};
   \node[state] (q_2) [below right =of q_0] {$q_2$};
   \node[draw=none,fill=none] (Q_E) [right = of q_1] {$S$};
   \node[draw=none,fill=none] (Q_F) [right = of q_2] {$S$};
   \node[state] (q_3) [right=of Q_E] {$q_3$};
   \node[state] (q_4) [right=of Q_F] {$q_4$};
   \node[state, accepting] (q_5) [below right =of q_3] {$q_5$};
   \path[->]
   (q_0) edge node {$\varepsilon$} (q_1)
   (q_0) edge node {$\varepsilon$} (q_2)
   (q_3) edge node {$\varepsilon$} (q_5)
   (q_4) edge node {$\varepsilon$} (q_5);
\end{tikzpicture}
\end{center}
\item se $R=ST$ quindi $L(R)=L(S)L(T)$:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
   \node[state,initial] (q_0)   {$q_0$};
   \node[draw=none,fill=none] (Q_E) [right = of q_0] {$S$}; 
   \node[state] (q_1) [ right =of Q_E] {$q_1$};
   \node[state] (q_2) [right =of q_1] {$q_2$};
   \node[draw=none,fill=none] (Q_F) [right = of q_2] {$T$};
   \node[state] (q_3) [right=of Q_F] {$q_3$};
   \node[draw=none,fill=none] (Q_G) [right = of q_3] {};
   \path[->]
   (q_1) edge node {$\varepsilon$} (q_2)
   (q_3) edge node {} (Q_G);
\end{tikzpicture}
\end{center}
\item se $R=S^*$ quindi $L(R)=(L(S))^*$:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
   \node[state,initial] (q_0)   {$q_0$}; 
   \node[state] (q_1) [ right =of Q_E] {$q_1$};
   \node[draw=none,fill=none] (Q_F) [right = of q_1] {$S$};
   \node[state] (q_2) [right =of Q_F] {$q_2$};
   \node[state] (q_3) [right=of q_2] {$q_3$};
   \path[->]
   (q_0) edge node {$\varepsilon$} (q_1)
   (q_2) edge [bend right = 35]  node {$\varepsilon$} (q_1)
   (q_0) edge [bend right = 25] node  {$\varepsilon$} (q_3)
   (q_2) edge node {$\varepsilon$} (q_3);
\end{tikzpicture}
\end{center}
\end{enumerate}
\end{itemize}
\newpage
\begin{esempio}
creo E-NFA per 
$$ER=(0+1)^*1(0+1)$$
si ha che per 0+1:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
   \node[state,initial] (q_0)   {$q_0$}; 
   \node[state] (q_1) [above right =of q_0] {$q_1$};
   \node[state] (q_2) [below right =of q_0] {$q_2$};
   \node[state] (q_3) [right=of q_1] {$q_3$};
   \node[state] (q_4) [right=of q_2] {$q_4$};
   \node[state] (q_5) [below right =of q_3] {$q_5$};
   \path[->]
   (q_0) edge node {$\varepsilon$} (q_1)
   (q_0) edge node {$\varepsilon$} (q_2)
   (q_1) edge node {$0$} (q_3)
   (q_2) edge node {$1$} (q_4)
   (q_3) edge node {$\varepsilon$} (q_5)
   (q_4) edge node {$\varepsilon$} (q_5);
\end{tikzpicture}
\end{center}
da qui ottengo $(0+1)^*$
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
   \node[state, initial] (q_i)   {$q_i$}; 
   \node[state] (q_0) [right of = q_i]  {$q_0$}; 
   \node[state] (q_1) [above right =of q_0] {$q_1$};
   \node[state] (q_2) [below right =of q_0] {$q_2$};
   \node[state] (q_3) [right=of q_1] {$q_3$};
   \node[state] (q_4) [right=of q_2] {$q_4$};
   \node[state] (q_5) [below right =of q_3] {$q_5$};
   \node[state, accepting] [right of =q_5] (q_f)   {$q_f$}; 
   \path[->]
   (q_i) edge node {$\varepsilon$} (q_0)
   (q_i) edge [bend right =65] node {$\varepsilon$} (q_f)
   (q_0) edge node {$\varepsilon$} (q_1)
   (q_0) edge node {$\varepsilon$} (q_2)
   (q_1) edge node {$0$} (q_3)
   (q_5) edge  [bend right =100] node [above] {$\varepsilon$} (q_0)
   (q_2) edge node {$1$} (q_4)
   (q_3) edge node {$\varepsilon$} (q_5)
   (q_5) edge node {$\varepsilon$} (q_f)
   (q_4) edge node {$\varepsilon$} (q_5);
\end{tikzpicture}
\end{center}
unisco e aggiungo uno nel mezzo:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=1.4cm,on grid,auto] 
   \node[state, initial] (q_i)   {$q_i$}; 
   \node[state] (q_0) [right of = q_i]  {$q_0$}; 
   \node[state] (q_1) [above right =of q_0] {$q_1$};
   \node[state] (q_2) [below right =of q_0] {$q_2$};
   \node[state] (q_3) [right=of q_1] {$q_3$};
   \node[state] (q_4) [right=of q_2] {$q_4$};
   \node[state] (q_5) [below right =of q_3] {$q_5$}; 
   \node[state] (q_f) [below right =of q_5] {$q_f$};
   
   \node[state] (q_m) [right of = q_f]  {$q_m$}; 
   \node[state] (q_n) [right =of q_m] {$q_n$};
    
   \node[state] (q_6) [right of = q_n]  {$q_6$}; 
   \node[state] (q_7) [above right =of q_6] {$q_7$};
   \node[state] (q_8) [below right =of q_6] {$q_8$};
   \node[state] (q_9) [right=of q_7] {$q_9$};
   \node[state] (q_a) [right=of q_8] {$q_a$};
   \node[state] (q_b) [below right =of q_9] {$q_b$};
   \path[->]
   (q_i) edge node {$\varepsilon$} (q_0)
   (q_i) edge [bend right =65] node {$\varepsilon$} (q_f)
   (q_0) edge node {$\varepsilon$} (q_1)
   (q_0) edge node {$\varepsilon$} (q_2)
   (q_1) edge node {$0$} (q_3)
   (q_5) edge  [bend right =100] node [above] {$\varepsilon$} (q_0)
   (q_2) edge node {$1$} (q_4)
   (q_3) edge node {$\varepsilon$} (q_5)
   (q_5) edge node {$\varepsilon$} (q_f)
   (q_4) edge node {$\varepsilon$} (q_5)
   (q_f) edge node  {$\varepsilon$} (q_m)
   (q_m) edge node  {$1$} (q_n)
   (q_n) edge node  {$\varepsilon$} (q_6)
   (q_6) edge node {$\varepsilon$} (q_7)
   (q_6) edge node {$\varepsilon$} (q_8)
   (q_6) edge node {$0$} (q_8)
   (q_7) edge node {$1$} (q_9)
   (q_8) edge node {$\varepsilon$} (q_a)
   (q_a) edge node {$\varepsilon$} (q_b)
   (q_9) edge node {$\varepsilon$} (q_b);
\end{tikzpicture}
\end{center}
\end{esempio}
Vediamo ora l'algoritmo che trasforma DFA in una ER. Questo algoritmo permette di verificare quale linguaggio è accettato o meno dall'automa:\\
dato DFA $A=(Q,\Sigma, \delta, q_0,F)$ con $Q$ e $F$ stati non finali e $Q$, $F$, $q_0$ che sono i primi stati da eliminare. L'algoritmo procede per eliminazioni successive. Si costruisce quindi l'automa $B$ che ha solo $q_0$ e $F=\{q_1,...,q_k\}$. Scrivo quindi $K$ espressioni regolari considerando solo $q_0$ e il k-esimo stato finale eliminando pian piano gli altri stati. Alla fine ottengo le varie espressioni regolari da unire: 
$$E=E1+E2+\cdots+Ek$$
vediamo ora come eliminare uno stato. Partiamo dal seguente automa:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=4cm,on grid,auto] 
   \node[state] (q_1)   {$q_1$}; 
   \node[state] (s) [below right =of q_1] {$s$};
   \node[state] (q_k) [below left =of s] {$q_k$};
   \node[state] (p_1) [above right=of s] {$p_1$};
   \node[state] (p_m) [below right =of s] {$p_m$};
   \path[->]
   (q_1) edge node {$Q_1$} (s)
   (q_1) edge [bend left =50] node {$R_{11}$} (p_1)
   (q_1) edge [bend left =100] node {$R_{1m}$} (p_m)
   (s)   edge node {$p_1$} (p_1)
   (s)   edge node {$p_m$} (p_m)
   (s)   edge [loop above] node {$S$} ()
   (q_k) edge node {$Q_k$} (s)
   (q_k) edge [bend right =50] node {$R_{k1}$} (p_1)
   (q_k) edge [bend right =100] node {$R_{km}$} (p_m);
\end{tikzpicture}
\end{center}
\newpage
ed elimino $s$:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=4cm,on grid,auto] 
   \node[state] (q_1)   {$q_1$}; 
   \node[state] (q_k) [below =of q_1] {$q_k$};
   \node[state] (p_1) [right=of q_1] {$p_1$};
   \node[state] (p_m) [below  =of p_1] {$p_m$};
   \path[->]
   (q_1) edge node {$R_{11}+Q_1S^{*}P_1$} (p_1)
   (q_1) edge node [right]{$R_{1m}+Q_1S^{*}P_m$} (p_m)
   (q_k) edge node [left]{$R_{k1}+Q_kS^{*}P_1$} (p_1)
   (q_k) edge node {$R_{km}+Q_kS^{*}P_m$} (p_m);
\end{tikzpicture}
\end{center}
quindi quando si ha uno stato iniziale $q_0$ e uno finale $q_1$:
\begin{itemize}
\item se $q_0\neq q_1$:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
   \node[state, initial] (q_0)   {$q_1$}; 
   \node[state, accepting] (q_1) [right=of q_1] {$q_k$};
   \path[->]
   (q_0) edge [bend left =25]node {$S$} (q_1)
   (q_1) edge [bend left =25]node {$T$} (q_0)
   (q_0)   edge [loop above] node {$R$} ()
   (q_1)   edge [loop above] node {$U$} ();
\end{tikzpicture}
\end{center}
rappresenta:
$$E_i=(R+SU^{*}T)^{*}SU^{*}$$
\item se $q_0=q$:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
   \node[state, initial, accepting] (q_0)   {$q_1$}; 
   \path[->]
   (q_0)   edge [loop above] node {$R$} ();
\end{tikzpicture}
\end{center}
rappresenta:
$$E_i=R^{*}$$
\end{itemize}
\newpage
\begin{esempio}
passo dall'automa a l'espressione regolare:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
\node[state, initial] (q_0) {$A$};
	\node[state] (q_1) [right=of q_0] {$B$};
	\node[state, accepting] (q_2) [right=of q_1] {$C$};
	\node[state, accepting] (q_3) [right=of q_2] {$D$};
	\path[->]
	(q_0) edge  node {1} (q_1)
	      edge [loop above] node {0,1} ()
	(q_1) edge  node {0,1} (q_2)
	(q_2) edge  node {0,1} (q_3);
\end{tikzpicture}
\end{center}
questo automa accetta le stringhe binarie con un uno in penultima o terzultima posizione.\\
Rietichetto con le ER:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
\node[state, initial] (q_0) {$A$};
	\node[state] (q_1) [right=of q_0] {$B$};
	\node[state, accepting] (q_2) [right=of q_1] {$C$};
	\node[state, accepting] (q_3) [right=of q_2] {$D$};
	\path[->]
	(q_0) edge  node {1} (q_1)
	      edge [loop above] node {0+1} ()
	(q_1) edge  node {0+1} (q_2)
	(q_2) edge  node {0+1} (q_3);
\end{tikzpicture}
\end{center}
elimino B che non è iniziale o finale . Il predecessore di B è A e il successore è C. Si ha quindi:
$$A\to B:1$$
$$B\to C:0+1$$
e non ho loop in B ($\emptyset$) e nessun arco tra A e C ($R_{a,c}=\emptyset$). Quindi:
$$R_{A,C}^{'}=\emptyset+1\emptyset^*(0+1)=1(0+1)$$
ovvero:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
\node[state, initial] (q_0) {$A$};
	\node[state, accepting] (q_2) [right=of q_0] {$C$};
	\node[state, accepting] (q_3) [right=of q_2] {$D$};
	\path[->]
	(q_0) edge  node {1(0+1)} (q_2)
	      edge [loop above] node {0+1} ()
	(q_2) edge  node {0+1} (q_3);
\end{tikzpicture}
\end{center}
Ho ora solo stati iniziali e finali, quindi $E=E_1+E_2$. 
Trovo $E1$, elimino quindi C. Si ha:
$$A\to C:1(0+1)$$
$$C\to D:0+1$$
e non ho loop in B ($\emptyset$) e nessun arco tra A e D($R_{A,D}=\emptyset$), ovvero:
$$R_{A,D}=\emptyset+1(0+1)\emptyset^*(0+1)=1(0+1)(0+1)$$
che è:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=4cm,on grid,auto] 
\node[state, initial] (q_0) {$A$};
	\node[state, accepting] (q_3) [right=of q_0] {$D$};
	\path[->]
	(q_0) edge  node {1(0+1)(0+1)} (q_3)
	      edge [loop above] node {0+1} ();
\end{tikzpicture}
\end{center}
quindi:
$$E_1=((0+1)+1(0+1)(0+1)\emptyset^*\emptyset)^*1(0+1)(0+1)\emptyset^*=(0+1)^*1(0+1)(0+1)$$
ottengo $E2$ eliminando D che non ha successori, quindi:
$$E_2=(0+1)^*1(0+1)$$
e quindi infine:
$$E=E_1+E_2=(0+1)^*1(0+1)(0+1)+(0+1)^*1(0+1)=(0+1)^*1(0+1)(\varepsilon+0+1)$$
\end{esempio}
\begin{esempio}
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
\node[state, initial, accepting] (q_0) {$p$};
	\node[state] (q_1) [right =of q_0] {$s$};
	\node[state] (q_2) [right=of q_1] {$r$};
	\node[state] (q_3) [below=of q_1] {$q$};
	\path[->]
	(q_0) edge  node {0} (q_1)
	      edge [loop above] node {1} ()
	(q_1) edge [bend left = 25] node {0} (q_3)
    (q_1) edge  node {1} (q_2)
    (q_2) edge  [bend left = 25] node {1} (q_3)
	      edge [loop above] node {0} ()
	(q_3) edge  [bend left = 25] node {1} (q_1)
	(q_3) edge  [bend left = 25] node {0} (q_0);
\end{tikzpicture}
\end{center}
rimuovo $r$:
$$s\to r:1$$
$$r\to q:1$$
$$loop:0$$
$$R_{s,q}=0$$
Si ottiene quindi:
$$R^{'}_{s,q}=0+10^*1$$
ovvero:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
\node[state, initial, accepting] (q_0) {$p$};
	\node[state] (q_1) [right =of q_0] {$s$};
	\node[state] (q_3) [below=of q_1] {$q$};
	\path[->]
	(q_0) edge  node {0} (q_1)
	      edge [loop above] node {1} ()
	(q_1) edge [bend left = 25] node {$0+10^*1$} (q_3)
	(q_3) edge  [bend left = 25] node {1} (q_1)
	(q_3) edge  [bend left = 25] node {0} (q_0);
\end{tikzpicture}
\end{center}
elimino ora $s$, che ha due predecessori, $p$ e $q$, quindi:
$$p\to s:0$$
$$q\to s:1$$
$$s\to q:0+10^*1$$
non ha loop e non ha archi diretti tra $p$ e $q$ ($R_{p,q}=\emptyset$). Si ottengono quindi:
$$R_{p,q}=\emptyset+0\emptyset^*(0+10^*1)=0(0+10^*1)$$
$$R_{q,q}=\emptyset+10^*(0+10^*1)=1(0+10^*1)$$
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=4cm,on grid,auto] 
\node[state, initial, accepting] (q_0) {$p$};
	\node[state] (q_3) [right=of q_0] {$q$};
	\path[->]
	(q_0) edge [bend left = 25] node {$0(0+10^*1)$} (q_3)
	      edge [loop above] node {1} ()
	(q_3) edge  [bend left = 25] node {0} (q_0)
		  edge [loop above] node {$1(0+10^*1)$} ();
\end{tikzpicture}
\end{center}
elimino ora $q$ che ha $p$ sia come predecessore che come successore:
$$p\to q: 0(0+10^*1)$$
$$q\to p:0$$
$$loop: 1(0+10^*1)$$
$$R_{p,p}:1$$
ottenendo:
$$R^{'}_{p,p}=1+0(0+10^*1)(1(0+10^*1))^*0=1+(00+010^*1)(10+110^*1)^*0$$
\newpage
ovvero:

\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=4cm,on grid,auto] 
\node[state, initial, accepting] (q_0) {$p$};
	\path[->]
	   (q_0)   edge [loop above] node {$1+(00+010^*1)(10+110^*1)^*0$} ();
\end{tikzpicture}
\end{center}
Essendo $p$ sia iniziale che finale si ha:
$$E=(1+(00+010^*1)(10+110^*1)^*0)^*$$
\end{esempio}
\subsection{Chiusura di un Linguaggio regolare}
Sia $REG$ la classe dei linguaggi regolari (ovvero ogni linguaggio regolare su un alfabeto finito non vuoto). Si ha la seguente proprietà:
$$L,M\in REG\to L\cup M\in REG$$
si può dimostrare in due maniere:
\begin{itemize}
\item \textbf{con le espressioni regolari:}
$$L,M\in REG \to \exists R, S \mbox{ ER tali che } L(R)=L \mbox { e } L(S)=M$$
$$L\cup M=L(R+S) \mbox{ e quindi appartenente a } REG$$
\item \textbf{con gli automi:}
$$\mbox{se }L,M\in REG\to \exists \varepsilon-NFA \mbox{ che con L e M va dallo stato iniziale a quello finale}$$:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
   \node[state,initial] (q_0)   {$q_0$}; 
   \node[state] (q_1) [above right =of q_0] {$q_1$};
   \node[state] (q_2) [below right =of q_0] {$q_2$};
   \node[draw=none,fill=none] (Q_E) [right = of q_1] {$L$};
   \node[draw=none,fill=none] (Q_F) [right = of q_2] {$M$};
   \node[state] (q_3) [right=of Q_E] {$q_3$};
   \node[state] (q_4) [right=of Q_F] {$q_4$};
   \node[state, accepting] (q_5) [below right =of q_3] {$q_5$};
   \path[->]
   (q_0) edge node {$\varepsilon$} (q_1)
   (q_0) edge node {$\varepsilon$} (q_2)
   (q_3) edge node {$\varepsilon$} (q_5)
   (q_4) edge node {$\varepsilon$} (q_5);
\end{tikzpicture}
\end{center}
accetta $L\cup M$ che quindi è $REG$
\end{itemize}
Inoltre siano due i due alfabeti $\Sigma\subseteq\Gamma$, si ha che:
$$\mbox{se L è regolare su }\Sigma\to \mbox{L è regolare su }\Gamma$$
inoltre:
$$\mbox{se L è REG su }\Sigma_1, \mbox{ M è REG su }\Sigma_2, \mbox{ allora } L\cup M \mbox{ è REG su }\Sigma_1\cup\Sigma_2$$
\begin{teorema}
Si ha che:\\
Se L e M sono linguaggi regolari allora LM, ovvero la concatenazione è regolare.\\
Se L è un linguaggio regolare allora $L^*$ è regolare
\end{teorema}
\begin{teorema}
se $L\in REG$ su $\Sigma$ allora $\overline{L}=\Sigma^*-L\in REG$
\end{teorema}
\begin{proof}
se $L\in REG$ allora $\exists$ DFA $A=(Q, \Sigma, \delta, q_0, F)$ tale che $L(A)=L$. Costruisco $B=(Q,\Sigma, \delta,q_0, Q-F),\,	 L(B)=\overline{L}$.\\
\end{proof}
si osserva che:
$$L\in REG\,\,su\,\, \Sigma\,\,e\,\, \Sigma\subseteq \Gamma$$
inoltre:
$$\overline{L}=\Sigma^*-L\,\,oppure\,\, \overline{L}=\Gamma^*-L$$
\textit{Se ho un espressione regolare per L e voglio ottenere un'espressione regolare per }$\overline{L}$\textit{ devo ottenere un }$\varepsilon-NFA$\textit{ che devo convertire in DFA. A quel punto complemento con F e ottengo un'espressione regolare per }$\overline{L}$.\\
Passiamo ora all'intersezione:
\begin{teorema}
se $L$ e $M$ sono regolari allora la loro intersezione è regolare
\end{teorema}
\begin{proof}
$$L,M\in REG\to \exists A_L,A_M(DFA) \mbox{ tali che }L(A_L)=L\,\,e\,\, L(A_M)=M$$
e quindi:
\begin{center}
\psscalebox{1.0 1.0} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,-1.6)(9.75,1.6)
\psframe[linecolor=black, linewidth=0.04, dimen=outer](2.0,0.4)(0.0,-0.4)
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(2.0,0.4)(3.6,1.2)
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(2.0,-0.4)(3.6,-1.2)
\psframe[linecolor=black, linewidth=0.04, dimen=outer](5.2,1.6)(3.6,0.8)
\psframe[linecolor=black, linewidth=0.04, dimen=outer](5.2,-0.8)(3.6,-1.6)
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(5.2,1.2)(6.8,0.0)
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(5.2,-1.2)(6.8,0.0)
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(7.52,0.0)(8.72,0.0)
\rput[bl](0.54,-0.08){$w\in\Sigma^*$}
\rput[bl](4.24,1.08){$A_L$}
\rput[bl](4.14,-1.32){$A_M$}
\rput[bl](6.94,-0.1){$\wedge$}
\rput[bl](5.74,0.84){$\frac{accetta}{rifiuta}$}
\rput[bl](5.98,-1.14){$\frac{accetta}{rifiuta}$}
\rput[bl](8.82,-0.24){$\frac{accetta}{rifiuta}$}
\psbezier[linecolor=black, linewidth=0.04](6.7660146,-0.39855364)(7.5631223,-0.46652403)(7.6310925,0.33058324)(6.8339853,0.3985536432683381)
\psline[linecolor=black, linewidth=0.04](6.8,0.4)(6.8,-0.4)
\end{pspicture}
}
\end{center}
\end{proof}
Passiamo al problema della \textbf{chiusura dei linguaggi regolari rispetto all'intersezione}, ovvero che due automi che usano entrambi contemporaneamente una certa stringa in input, il ché non è possibile. Si risolve usando l'\textbf{automa prodotto}:
$$A=(Q_L\times Q_M,\Sigma, \delta, (q_{OL},q_{OM}).F_L\times F_M)$$
con:
$$\delta(p,q),a)=(\delta_L(p,a),\delta_M(q,a))$$
$$A_L=(Q_L,\Sigma,\delta_L,q_{OL},F_L)$$
$$A_M=(Q_M,\Sigma,\delta_M,q_{OM},F_M)$$
\begin{esempio}
Siano:\\
$A_L$, stringhe binarie con almeno uno zero:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
	\node[state, initial] (q_0) {$r$};
	\node[state, accepting] (q_1) [right=of q_0] {$s$};
	\path[->]
	(q_0) edge node {0} (q_1)
	      edge [loop above] node {1} ()
	(q_1) edge [loop above] node {0,1} ();
\end{tikzpicture}
\end{center}
$A_M$, stringhe binarie con almeno un uno:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
	\node[state, initial] (q_0) {$p$};
	\node[state, accepting] (q_1) [right=of q_0] {$q$};
	\path[->]
	(q_0) edge node {1} (q_1)
	      edge [loop above] node {0} ()
	(q_1) edge [loop above] node {0,1} ();
\end{tikzpicture}
\end{center}
ottengo l'automa prodotto:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
	\node[state, initial] (q_0) {$p,r$};
	\node[state] (q_1) [right=of q_0] {$p,s$};
	\node[state] (q_2) [below=of q_0] {$q,r$};
	\node[state, accepting] (q_3) [right=of q_2] {$q,s$};
	\path[->]
	(q_0) edge  node {1} (q_1)
	      edge  node {0} (q_2)
	(q_1) edge  node {0} (q_3)
	      edge [loop above] node {1} ()
	(q_2) edge  node {1} (q_3)
	      edge [loop below] node {0} ()
	(q_3) edge [loop below] node {0,1} ();
\end{tikzpicture}
\end{center}
$$\delta((p,r),0)=(\delta_L(p,o),\delta_M8r,o))=(q,r)$$
\end{esempio}

\begin{esempio}
Siano:\\
$A$, stringhe contenenti $a$ e $b$ contenenti almeno una $b$:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
	\node[state, initial] (q_0) {$q_0$};
	\node[state, accepting] (q_1) [right=of q_0] {$q_1$};
	\path[->]
	(q_0) edge node {a} (q_1)
	      edge [loop above] node {b} ()
	(q_1) edge [loop above] node {a,b} ();
\end{tikzpicture}
\end{center}
$A_M$, stringhe contenenti $a$ e $b$ contenenti $2n,\,n\geq 0$ $b$:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
	\node[state, initial, accepting] (q_0) {$p_0$};
	\node[state] (q_1) [right=of q_0] {$p_1$};
	\path[->]
	(q_0) edge [bend left = 25] node {b} (q_1)
	      edge [loop above] node {a} ()
	(q_1) edge [bend left = 25] node {b} (q_0)
		  edge [loop above] node {a} ();
\end{tikzpicture}
\end{center}
si ha che $L(A\wedge B)$ è il linguaggio formato da stringhe contenenti $a$ e $b$ contenenti $2n,\,n\geq 1$ $b$:
faccio la tabella:
\begin{center}
\begin{tabular}{c|c|c}
& a & b \\
\hline
$\to (q_0,p_0)$ & $(q_0,p_0)$ & $(q_1,p_1)$\\
\hline
$ (q_1,p_1)$ & $(q_1,p_1)$ & $(q_1,p_0)$\\
\hline
$* (q_1,p_0)$ & $(q_1,p_0)$ & $(q_1,p_1)$
\end{tabular}
\end{center}
ottengo l'automa prodotto:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
	\node[state, initial] (q_0) {$q_0,p_0$};
	\node[state] (q_1) [right=of q_0] {$q_1,p_1$};
	\node[state,accepting] (q_2) [right=of q_1] {$q_1,p_0$};
	\path[->]
	(q_0) edge  node {b} (q_1)
	      edge [loop above] node {a} ()
	(q_1) edge [bend left =25] node {b} (q_2)
	      edge [loop above] node {a} ()
	(q_2) edge [bend left =25] node {b} (q_1)
	      edge [loop above] node {1} ();
\end{tikzpicture}
\end{center}
\end{esempio}

\begin{esempio}
si hanno due linguaggi $L(A)$ e $L(B)$ tali per cui la loro intersezione non è vuota.\\
Sia $A$:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
	\node[state, initial, accepting] (q_0) {$a$};
	\node[state] (q_1) [right=of q_0] {$b$};
	\path[->]
	(q_0) edge [bend left = 25] node {1} (q_1)
	      edge [loop above] node {0} ()
	(q_1) edge [bend left = 25] node {0} (q_0)
		  edge [loop above] node {1} ();
\end{tikzpicture}
\end{center}
e $B$:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
	\node[state, initial, accepting] (q_0) {$c$};
	\node[state, accepting] (q_1) [right=of q_0] {$d$};
	\node[state] (q_2) [below right=of q_0] {$e$};
	\path[->]
	(q_0) edge  node {0} (q_1)
		  edge [bend left =25] node {1} (q_2)
	(q_1) edge node {1} (q_2)
	      edge [loop above] node {0} ()
	(q_2) edge [bend left =25] node {0} (q_0)
	      edge [loop below] node {1} ();
\end{tikzpicture}
\end{center}
faccio la tabella:
\begin{center}
\begin{tabular}{c|c|c}
& 0 & 1 \\
\hline
$\stackrel{*}{\to} (a,c)$ & $(a,d)$ & $(b,e)$\\
\hline
$ *(a,d)$ & $(a,d)$ & $(b,e)$\\
\hline
$ (b,e)$ & $(a,c)$ & $(b,e)$
\end{tabular}
\end{center}
e ottengo:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
	\node[state, initial, accepting] (q_0) {$a,c$};
	\node[state] (q_1) [right=of q_0] {$b,e$};
	\node[state, accepting] (q_2) [below =of q_0] {$a,d$};
	\path[->]
	(q_0) edge  node {0} (q_2)
		  edge [bend left =25] node {1} (q_1)
		  edge [loop above] node {0} ()
	(q_1) edge [bend left =25] node {0} (q_0)
	      edge [loop above] node {1} ()
	(q_2) edge  node {1} (q_1);
\end{tikzpicture}
\end{center}
\end{esempio}


\begin{esempio}
Sia $A$:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
	\node[state, initial] (q_0) {$p_0$};
	\node[state, accepting] (q_1) [right=of q_0] {$p_1$};
	\path[->]
	(q_0) edge [bend left = 25] node {1} (q_1)
	      edge [loop above] node {0} ()
	(q_1) edge [bend left = 25] node {0} (q_0)
		  edge [loop above] node {1} ();
\end{tikzpicture}
\end{center}
e $B$:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
	\node[state, initial, accepting] (q_0) {$q_0$};
	\node[state] (q_1) [right=of q_0] {$q_1$};
	\node[state] (q_2) [below right=of q_0] {$q_2$};
	\path[->]
	(q_0) edge [bend left =25] node {0} (q_1)
	      edge [bend left =25] node {1} (q_2)
	(q_1) edge [bend left =25] node {1} (q_2)
	      edge [loop above] node {0} ()
	(q_2) edge [bend left =25] node {0} (q_0)
	       edge [bend left =25] node {1} (q_1);
\end{tikzpicture}
\end{center}
faccio la tabella:
\begin{center}
\begin{tabular}{c|c|c}
& 0 & 1 \\
\hline
$\to (p_0,q_0)$ & $(p_0,q_1)$ & $(p_1,q_2)$\\
\hline
$(p_0,q_1)$ & $(p_0,q_1)$ & $(p_1,q_2)$\\
\hline
$ (p_1,q_2)$ & $(p_0,q_0)$ & $(p_1,q_1)$\\
\hline
$ (p_1,q_1)$ & $(p_0,q_1)$ & $(p_1,q_2)$
\end{tabular}
\end{center}
non si raggiungono stati finali quindi $L(A\cap B)=\emptyset$
\end{esempio}
\subsection{Minimizzazione}
definiamo la \textbf{relazione di equivalenza tra stati}:
\begin{definizione}
Sia $A$ un $DFA$, $A=()Q,\Sigma,\delta,q_0,F)$. Siano:
$$p,q\in Q\to p\approx q\mbox{ vale se } \forall w \in \Sigma^*\,\,\, \stackrel{\wedge}{\delta}(p,w)\in F\longleftrightarrow \stackrel{\wedge}{\delta}(q,w)\in F$$
inoltre $p$ e $q$ sono distinguibili se $p\not\approx q$ ovvero:
$$\exists w\in \Sigma^*\mbox{ tale che:} $$
$$\stackrel{\wedge}{\delta}(p,w)\in F \,\,e\,\,\stackrel{\wedge}{\delta}(q,w)\not\in F\,\,o\,\,\stackrel{\wedge}{\delta}(p,w)\not\in F \,\,e\,\,\stackrel{\wedge}{\delta}(q,w)\in F$$
\end{definizione}
quindi si ha una \textbf{relazione di equivalenza} e quindi si hanno le tre proprietà:
\begin{itemize}
\item \textbf{riflessività:} $\forall p\in Q, p\approx p$
\item \textbf{simmetricità:} $\forall p,q\in Q, p\approx q\to q\approx p$
\item \textbf{transitività:} $\forall p,q,r\in Q, p\approx q\vee q\approx r\to p\approx r$
\end{itemize} 
e quindi \textbf{in ogni classe di equivalenza ci sono stati tra loro equivalenti}
due stati, uno finale e uno non finale, sono sicuramente distinguibili, basti pensare alla stringa vuota.
\begin{esempio}
Analizziamo il seguente automa:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=4cm,on grid,auto] 
	\node[state, initial] (q_0) {$a$};
	\node[state] (q_1) [right=of q_0] {$b$};
	\node[state, accepting] (q_2) [right=of q_1] {$c$};
	\node[state] (q_3) [right=of q_2] {$d$};
	\node[state] (q_4) [below=of q_0] {$e$};
	\node[state] (q_5) [right=of q_4] {$f$};
	\node[state] (q_6) [right=of q_5] {$g$};
	\node[state] (q_7) [right=of q_6] {$h$};
	\path[->]
	(q_0) edge node {1} (q_5)
	      edge node {0} (q_1)
	(q_1) edge node {1} (q_2)
		  edge node [below] {0} (q_6)
	(q_2) edge [bend right =25] node {0} (q_0)
	      edge [loop above] node {1} ()
	(q_3) edge node {0} (q_2)    
		  edge node [below]{1} (q_6) 
	(q_4) edge node {1} (q_5)
	      edge [bend right =45] node {1} (q_7)    
	(q_5) edge node [above] {0} (q_2)  
	      edge node {1} (q_6)  
	(q_6) edge [bend left =25] node {1} (q_4)    
		  edge [loop below] node {0} ()
	(q_7) edge node {0} (q_6)    
		  edge node [above] {1} (q_2);
\end{tikzpicture}
\end{center}
cerco di capire se $a$ e $g$ sono equivalenti:
\begin{itemize}
\item $\varepsilon$ non li distingue perché entrambi sono non accettanti
\item 0 non li distingue perché li porta rispettivamente in \textit{b} e \textit{g}, che non sono accettanti
\item 1 non li distingue perché li porta rispettivamente in \textit{f} e \textit{e}, che non sono accettanti
\item 01 li distingue perché $\stackrel{\wedge}{\delta}(a,01)=c$ e $\stackrel{\wedge}{\delta}(g,01)=e$ e il primo è accettante mentre il secondo no, quindi i due stati non sono equivalenti
\end{itemize}
si verifica che invece \textit{a} e \textit{e} sono equivalenti
\end{esempio}
diamo una definizione ricorsiva dell'equivalenza tra stati:
\begin{itemize}
\item \textbf{caso base:} se $p\in F$ e $q\not\in F$ o viceversa si ha che gli stati sono distinguibili
\item \textbf{caso passo:} se per $a\in \Sigma$ gli stati $r=\delta(p,a)$ e $s=\delta(q,a)$ sono distinguibili allora anche $p$ e $q$ lo sono
\end{itemize}
quindi se un certo arco w porta due stati a due diversi di cui uno è accettante essi sono distinti.\\
Esiste anche un algoritmo detto \textbf{riempi-tabella}:\\
partiamo dalla seguente tabella
\begin{center}
\begin{tabular}{c|c|c|c|c|c|c|c|}
\hline
b &  & / & / & / & / & / & /\\
\hline
c &  &  & / & / & / & / & /\\
\hline
d &  &  &  & / & / & / & /\\
\hline
e &  &  &  &  & / & / & /\\
\hline
f &  &  &  &  &  & / & /\\
\hline
g &  &  &  &  &  &  & /\\
\hline
h &  &  &  &  &  &  & \\
\hline
  & a & b & c & d & e & f & g\\
\hline
\end{tabular}
\end{center}
$c$ è accettante quindi segniamo tutte le caselle relative a $c$ per il caso base:
\begin{center}
\begin{tabular}{c|c|c|c|c|c|c|c|}
\hline
b &  & / & / & / & / & / & /\\
\hline
c & x & x & / & / & / & / & /\\
\hline
d &  &  & x & / & / & / & /\\
\hline
e &  &  & x &  & / & / & /\\
\hline
f &  &  & x &  &  & / & /\\
\hline
g &  &  & x &  &  &  & /\\
\hline
h &  &  & x &  &  &  & \\
\hline
  & a & b & c & d & e & f & g\\
\hline
\end{tabular}
\end{center}
poiché, per esempio $c,h$ è distinguibile e gli stati $e$ e $f$ con 0 vanno in $h$ e $c$ si ha che anche $e$ e $f$ sono distinguibili, segno quindi nelle caselle appropriate. Proseguo controllando anche le altre coppie e riempio le caselle. Ottengo:
\begin{center}
\begin{tabular}{c|c|c|c|c|c|c|c|}
\hline
b & x & / & / & / & / & / & /\\
\hline
c & x & x & / & / & / & / & /\\
\hline
d & x & x & x & / & / & / & /\\
\hline
e &  & x & x & x & / & / & /\\
\hline
f & x &  & x & x & x & / & /\\
\hline
g & x & x & x & x & x & x & /\\
\hline
h & x &  & x & x & x & x & x\\
\hline
  & a & b & c & d & e & f & g\\
\hline
\end{tabular}
\end{center}
quindi si ha solo che:
$$a\approx e\,\,b\approx h\,\,d\approx f$$
si ha che:
\begin{teorema}
due stati non distinti dall'algoritmo riempi-tabella sono equivalenti. Se ne calcola la complessità:
$$|Q|=n\to \frac{n(n-1)}{2}\,\,caselle=O(n^2)$$
se ho una crocetta a iterazione ho il caso peggiore $n^2n^2=O(n^4)$
\end{teorema}
quindi per vedere se due linguaggi regolari sono equivalenti si ha che:
$$L,M\in REG$$
$$\exists A_L=(Q_L,\Sigma,\delta_L,q_L,F_L)$$
$$\exists A_M=(Q_M,\Sigma,\delta_M,q_M,F_M)$$
costruisco $A=(Q_L\cup Q_M,\Sigma,\delta,q_L,F_L\cup F_M)$
\\$\delta$ è $\delta_L$ per $Q_L$ e $\delta$ è $\delta_M$ per $Q_M$
per vedere se $q_L\approx q_M$ uso il riempi tabella e se sono equivalenti si ha che $L=M$
\begin{esempio}
Sia $A$:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
	\node[state, initial, accepting] (q_0) {$a$};
	\node[state] (q_1) [right=of q_0] {$b$};
	\path[->]
	(q_0) edge [bend left = 25] node {1} (q_1)
	      edge [loop above] node {0} ()
	(q_1) edge [bend left = 25] node {0} (q_0)
		  edge [loop above] node {1} ();
\end{tikzpicture}
\end{center}
e $B$:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
	\node[state, initial, accepting] (q_0) {$c$};
	\node[state, accepting] (q_1) [right=of q_0] {$d$};
	\node[state] (q_2) [below =of q_0] {$e$};
	\path[->]
	(q_0) edge node {0} (q_1)
	      edge [bend right=25] node {1} (q_2)
	(q_1) edge node {1} (q_2)
	      edge [loop above] node {0} ()
	(q_2) edge [bend right =25] node {0} (q_0)
	      edge [loop below] node {1} ();
\end{tikzpicture}
\end{center}
entrambi i linguaggi accettano $(\varepsilon+(0+1)^*0)$
applico la tabella:
\begin{center}
\begin{tabular}{c|c|c|c|c|}
\hline
b & x & / & / & / \\
\hline
c &  & x & / & / \\
\hline
d &  & x &  & / \\
\hline
e & x &  & x & x \\
\hline
& a & b & c & d\\
\hline 
\end{tabular}
\end{center}
e quindi dato che $a\approx c$ si ha che i due linguaggi sono lo stesso linguaggio. \\
\textbf{CHIEDERE SPIEGAZIONI A RIGUARDO}
\end{esempio}
passiamo ora alla \textbf{minimizzazione}, che prende in input un DFA $A$ e restituisce un $DFA$ $A_{min}$ tale che $L(A)=L(A_{min})$ e che $A_{min}$ ha il numero più piccolo possibile di stati per distinguere $L(A)$.\\
Procedo così:
\begin{enumerate}
\item si rimuovono gli stati non raggiungibili
\item applico la tabella per scoprire le tabelle di equivalenza, gli stati del nuovo automa sono le classi di equivalenza
\end{enumerate}
si ha che lo stato iniziale è la classe di equivalenza dello stato finale e gli stati finali sono le classi di equivalenza degli stati finali.\\
La minimizzazione si dimostra per assurdo:\\
Sia $M$ il DFA ottenuto dalla tabella. Suppongo esista un DFA $N$ tale che $L(A)=L(N)\,|Q_N|<|Q_M|$. I due stati iniziali sono indistinguibili. Sia $p\in M\,\,q\in N$ tali $p\approx q\,\, \forall a\in\Sigma$ quindi $\delta p,a)=\delta(q,a)$, Ogni stato $p\in Q_;$è quindi indistinguibile da almeno uno stato di $N$. Avendo però $N$ meno stati si avranno almeno due stati di $M$ indistinguibili dallo stesso di $N$ ma non sono indistinguibili per la tabella. SI ha un assurdo.
\begin{esempio}
Si ha il seguente automa:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=4cm,on grid,auto] 
	\node[state, initial] (q_0) {$a$};
	\node[state] (q_1) [right=of q_0] {$b$};
	\node[state, accepting] (q_2) [right=of q_1] {$c$};
	\node[state] (q_3) [right=of q_2] {$d$};
	\node[state] (q_4) [below=of q_0] {$e$};
	\node[state, accepting] (q_5) [right=of q_4] {$f$};
	\node[state] (q_6) [right=of q_5] {$g$};
	\node[state] (q_7) [right=of q_6] {$h$};
	\node[state, accepting] (q_8) [below=of q_5] {$i$};
	\path[->]
	(q_0) edge node {1} (q_4)
	      edge node {0} (q_1)
	(q_1) edge node {0} (q_2)
		  edge [bend left =25] node {1} (q_5)
	(q_2) edge [bend left =25] node {1} (q_7)
	      edge node {0} (q_3)
	(q_3) edge node {1} (q_7)    
		  edge [bend right= 85] node {0} (q_4) 
	(q_4) edge node {0} (q_5)
	      edge [bend left =25] node {1} (q_8)    
	(q_5) edge [bend left = 25] node {0} (q_1)  
	      edge node {0} (q_6)  
	(q_6) edge node {1} (q_1)    
		  edge node {0} (q_7)  
	(q_7) edge node {0} (q_8)    
		  edge [bend left = 25] node {1} (q_2)  
	(q_8) edge [bend left = 25] node {1} (q_4)    
		  edge [bend left = 85] node {0} (q_0);
\end{tikzpicture}
\end{center}
faccio la tabella
\begin{center}
\begin{tabular}{c|c|c|c|c|c|c|c|c|}
\hline
b &  & / & / & / & / & / & / & /\\
\hline
c & x & x & / & / & / & / & / & /\\
\hline
d &  & z & x & / & / & / & / & /\\
\hline
e & x &  & x & x & / & / & / & /\\
\hline
f & x & x &  & x & x & / & / & /\\
\hline
g &  & x & x &  & x & x & / & /\\
\hline
h & x &  & x & x &  & x & x & / \\
\hline
i & x & x &  & x & x &  & x & x\\
\hline
  & a & b & c & d & e & f & g & h\\
\hline
\end{tabular}
\end{center}
al caso base segno tutte le caselle degli stati accettanti tranne quelle che incrociano con altri stati accettanti e poi completo il resto della tabella. Ottengo:
$$a\approx d\approx g$$
$$b\approx e\approx h$$
$$c\approx f\approx i$$

e quindi ottengo, l'automa minimizzato:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=4cm,on grid,auto] 
	\node[state, initial] (q_0) {$\{a,d,g\}$};
	\node[state] (q_1) [right=of q_0] {$\{b,e,h\}$};
	\node[state, accepting] (q_2) [below =of q_0] {$\{c,f,i\}$};
	\path[->]
	(q_0) edge node {0,1} (q_1)
	(q_1) edge [bend left =25] node {0,1} (q_2)
	(q_2) edge [bend left =25] node {1} (q_1)
	      edge node {0} (q_0);
\end{tikzpicture}
\end{center}
\end{esempio}
\begin{esempio}
Sia $A$:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
	\node[state, initial, accepting] (q_0) {$a$};
	\node[state] (q_1) [right=of q_0] {$b$};
	\path[->]
	(q_0) edge [bend left = 25] node {1} (q_1)
	      edge [loop above] node {0} ()
	(q_1) edge [bend left = 25] node {0} (q_0)
		  edge [loop above] node {1} ();
\end{tikzpicture}
\end{center}
e $B$:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
	\node[state, initial, accepting] (q_0) {$c$};
	\node[state, accepting] (q_1) [right=of q_0] {$d$};
	\node[state] (q_2) [below =of q_0] {$e$};
	\path[->]
	(q_0) edge node {0} (q_1)
	      edge [bend right=25] node {1} (q_2)
	(q_1) edge node {1} (q_2)
	      edge [loop above] node {0} ()
	(q_2) edge [bend right =25] node {0} (q_0)
	      edge [loop below] node {1} ();
\end{tikzpicture}
\end{center}
riduco $B$:
\begin{center}
\begin{tabular}{c|c|c}
\hline
d & & /\\
\hline
e & x & x\\
\hline
 & c & d\\
 \hline
\end{tabular}
\end{center}
quindi $c\approx d$. Ottengo quindi:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
	\node[state, initial, accepting] (q_0) {$\{c,d\}$};
	\node[state] (q_1) [right=of q_0] {$e$};
	\path[->]
	(q_0) edge [bend left = 25] node {1} (q_1)
	      edge [loop above] node {0} ()
	(q_1) edge [bend left = 25] node {0} (q_0)
		  edge [loop above] node {1} ();
\end{tikzpicture}
\end{center}
quindi $A$ è $B$ minimizzato, per questo riconoscevano lo stesso linguaggio 
\end{esempio}
La tabella non funziona ovviamente por gli NFA
\subsection{Pumping Lemma per i linguaggi regolari}
Questo lemma serve a dimostrare che un linguaggio L non è regolare. Si procede per assurdo.\\
Partiamo da un esempio:
$$L_{01}=\{0^n1^n|\,n\geq 1\}=\{01,0011,...\}$$
supponiamo che questo linguaggio sia rappresentabile da un DFA $A$ con $k$ stati ($L(A)=L_{01}$).\\
$0^k$ implica $k+1$ prefissi: $\varepsilon,0,00,000,...,0^k$ e quindi $\exists i,j$ tali che $0^i$ e $0^j$ finiscono nello stesso stato. Allora l'automa è ingannabile e accetterebbe $0^i0^j$ con $i\neq j$.\\
Formalmente si ha:
\begin{teorema}
Sia $L\in REG$ allora $\exists n$ che dipende da $L$ tale che $\forall w\in L$ con $|w|\geq n$, $w$ può essere scomposta in tre stringhe $w=xyz$ in modo che:
$$y\neq \varepsilon$$
$$|xy|\leq n$$
$$\forall k\geq 0\,\,\, zy^kz\in L$$
in altre parole posso sempre trovare una stringa non vuota $y$ non troppo distante dall'inizio di $w$, da $replicare$ da ripetere o cancellare ($k=0$) senza uscire dal linguaggio $L$
\end{teorema}
\begin{proof}
essendo $L\in REG$ esiste un DFA $A$ tale che $L=L(A)$. Suppongo $|Q|=n$ e considero $w=a_1a_2...a_n$ con $m\geq n$. Sia:
$$p_i=\stackrel{\wedge}{\delta}(q_0,a_1,...a_i)\,\,\forall i=0,1,...,n$$
quindi:
$$p_0=q_0,p_1,...,p_n\to n+a\,\,stati$$
allora $\exists i,j$, con $0\leq i<j\leq n$ tali che $p_i=p_j$. Scompongo ora $w$ in $w=xyz$ con:
$$x=a_1a_2...a_n$$
$$y=a_{i+1}a_{i+2}...a_j$$
$$z=a_{j+1}a_{j+2}...a_m$$
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
	\node[state, initial] (q_0) {$p_0$};
	\node[state] (q_1) [right=of q_0] {$p_i$};
	\node[state, accepting] (q_2) [right =of q_1] {$\mbox{ }$} ;
	\path[->]
	(q_0) edge node {x} (q_1)
	(q_1) edge node {z} (q_2)
	      edge [loop above] node {y} ();
\end{tikzpicture}
\end{center}
\end{proof}
\begin{esempio}
mostriamo che L01 non è regolare. Suppongo per assurdo che sia regolare, allora vale il pumping lemma. Sia $n\in\mathbb{N}$ la costante del pumping lemma. Pongo $w=0^n1^n=xyz$ tale che $|xy|=n$, ovvero $|xy|=0^n$, quindi $xy$ è formato da soli 0. Poniamo $x=0^{n-1}\,\,y=0\neq \varepsilon\,\, z=1^n$. Però per il pumping lemma $\forall k\geq 0\,\,\ xy^kz\in L_{01}$.
$$xy^kz=0^{n-1}0^k1^n=0^{n+k-1}1^n\in L_{01}$$
ma se $k\neq 1$ ciò non è vero e quindi il linguaggio non è regolare
\end{esempio}
\begin{esempio}
$L=\{w\in\{0,1\}^*|\, w=w^R\}$, linguaggio delle stringhe palindrome, è regolare?\\
suppongo per assurdo di sì, con $n$ costante del pumping lemma.\\
$w=0^n10^n$ quindi $x=0^{n-1}\,\,y=0\,\,z=10^n$.
Per $k=0$ si ha $xy^kz=0^{n-1}10^n\not\in L$, quindi non è regolare
\end{esempio}
\begin{esempio}
$L=\{1^p|\, p\,\,primo\}=\{11,111,11111\}$ è regolare?\\
$w=1^p=1^{n-1}11^{p-n}$ con:
$$x=1^{n-1}\,\,y=1\,\,z=1^{p-n}$$
per $k=0$ si ha $1^{p-1}$ e $p-1$ non è , quindi non è regolare
\end{esempio}
\begin{esempio}
$L=\{0^n1^m|\, n\leq m\}$ è regolare?\\
$w=0^{n-l}0^l1^{m}$ con:
$$x=0^{n-l}\,\,y=0^l\,\,z=1^{m}$$
con $|y|=l$ e $0<l\leq n$\\
quindi $\forall k\geq 0$ si ha $xy^kz\in L=0^{n-l}0^{kl}1^{m}$ con:
$$x=0^{n-l}\,\,y=0^{kl}\,\,z=1^{m}$$
scelgo $k$ tale che $b-l+kl=n+(k-1)l>m\to k> 1+\frac{m-n}{l}$ quindi non è regolare
\end{esempio}
\begin{esempio}
$L=\{0^n1^m|\, n\geq m\}$ è regolare?\\
$w=0^{n-l}0^l1^{m}$ con:
$$x=0^{n-l}\,\,y=0^l\,\,z=1^{m}$$
con $|zy|\leq n\,\,y\neq\varepsilon\,\,|y|=l$ e $0<l\leq n$\\
scelgo l tale che $n-l<m$ quindi non è regolare
\end{esempio}
\textbf{su appunti dispense altri esempi}
\section{Automi a Pila}
Si introduce un nuovo tipo di automa, il PDA (push down automata) che può essere pensato come un $\varepsilon-NFA$ col supporto di una pila (stack):
\begin{center}
\psscalebox{1.0 1.0} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,-2.04)(5.83,2.04)
\psframe[linecolor=black, linewidth=0.04, dimen=outer](3.2,2.04)(1.58,1.16)
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(0.0,1.58)(1.6,1.58)
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(3.2,1.58)(4.8,1.58)
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(2.4,0.38)(2.4,-0.42)
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(2.4,0.38)(2.4,1.18)
\psline[linecolor=black, linewidth=0.04](1.6,-0.42)(1.6,-2.02)
\psline[linecolor=black, linewidth=0.04](3.2,-2.02)(1.6,-2.02)
\psline[linecolor=black, linewidth=0.04](3.2,-2.02)(3.2,-0.42)
\psline[linecolor=black, linewidth=0.04](1.6,-0.82)(3.2,-0.82)
\psline[linecolor=black, linewidth=0.04](1.6,-1.22)(3.2,-1.22)
\psline[linecolor=black, linewidth=0.04](1.6,-1.62)(3.2,-1.62)
\rput[bl](4.9,1.32){$\frac{accetta}{rifiuta}$}
\rput[bl](0.4,1.74){input}
\rput[bl](3.78,0.22){ stati finiti}
\rput[bl](3.6,-1.22){stack}
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(3.64,0.72)(2.38,1.62)
\rput[bl](3.78,0.56){controllo a}
\end{pspicture}
}
\end{center}
e viene definito un PDA $P$ come:
$$P=(Q,\Sigma,\Gamma,\delta,q_0,z_0,F)$$
con;
\begin{itemize}
\item $Q$: insieme finito e non vuoto di stati
\item $\Sigma$: alfabeto di simboli di input
\item $\Gamma$: alfabeto di simboli di stack
\item $q_0\in Q$: stato iniziale
\item $z_0\in \Gamma\backslash \Sigma$: simbolo iniziale dello stack
\item $F\in Q$: insieme degli stati accettanti o finali
\end{itemize}
si ha che:
$$\delta:Q\times(\Sigma\cup\{\varepsilon\}\times \Gamma\to 2^{Q\times \Gamma^*}$$
quindi:
$$\delta(q_0,a,X)=\{(p_1,X_1),(p_2,X_2),...\}\,insieme\,\,\,finito\,\,p_i\in Q\,\,X_i\in \Gamma^*$$
si hanno dei casi particolari:
\begin{itemize}
\item lo stato $p$ potrebbe coincidere con $Q$ e si avrebbe un cappio
\item se $\Gamma=\varepsilon$ si ha il pop di $X$ dallo stack
\item se $\Gamma=X$ si lascia lo stack invariato
\item se $\Gamma=Y\neq X$ si ha la sostituzione di $X$ con $Y$ in cima allo stack
\item se $\Gamma$ è una stringa di simboli si ha il la rimozione di $X$ dallo stack e l'aggiunta a uno a uno dei simboli nello stack
\end{itemize}
\newpage
\begin{esempio}
Trovo PDA per il linguaggio delle stringhe binarie  palindrome di lunghezza pari: $L=\{ww^R|w\in\{0,1\}^*\}$. Con $R$ che indica rovesciato\\
Si ha la CFG $G=(\{P\},\{0,1\},Prod,P)$ tale che:
$$P\to 0P0|1P1|\varepsilon$$
si hanno quindi tre stati:
\begin{itemize}
\item $q_0$ che è quello iniziale che legge $w$ e spinge i dati sullo stack
\item $q_1$ che letta $w$ legge i simboli di $wR$ e li confronta con quelli dello stack
\item $q_2$ sarà la stringa accettata
\end{itemize}
descriviamo formalmente l'automa con la funzione di transizione $\delta$.
PDA $P=(\{q_0,q_1,q_2\},\{0,1\}, \{o,1,z_0\},\delta,q_0,z_0,\{q_2\})$
ovvero:
$$\delta(q_0,0,z_0)=\{(q_0,1z_0)\}$$
$$\delta(q_0,1,z_0)=\{(q_0,0z_0)\}$$
$$\delta(q_0,0,0)=\{(q_0,00)\}$$
$$\delta(q_0,0,1)=\{(q_0,01)\}$$
$$\delta(q_0,1,0)=\{(q_0,10)\}$$
$$\delta(q_0,1,1)=\{(q_0,11)\}$$
$$\delta(q_0,\varepsilon,z_0)=\{(q_0,z_0)\}$$
$$\delta(q_0,\varepsilon,0)=\{(q_0,0)\}$$
$$\delta(q_0,\varepsilon,1)=\{(q_0,1)\}$$
$$\delta(q_1,0,0)=\{(q_1,\varepsilon)\}$$
$$\delta(q_2,1,1)=\{(q_1,\varepsilon)\}$$
$$\delta(q_2,\varepsilon,z_0)=\{(q_2,0z_0)\}$$
\newpage 
otteniamo il seguente PDA:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
	\node[state, initial] (q_0) {$q_0$};
	\node[state] (q_1) [right=of q_0] {$q_1$};
	\node[state, accepting] (q_2) [right =of q_1] {$q_2$};
	\path[->]
	(q_0) edge node [align=center] {$\varepsilon,0/0$\\$\varepsilon,1/1$\\$\varepsilon,z_0/z_0$} (q_1)
	      edge [loop below] node [align=center] {$0,z_0/0z_0$\\$1,z_0/1z_0$\\$0,0/00$\\$0,1/01$\\$1,0/10$\\$1,1/11$} ()
	(q_1) edge [loop below] node [align=center] {$0,0/\varepsilon$\\$1,1/\varepsilon$} ()
	      edge  node [align=center] {$\varepsilon,z_0/z_0$} (q_2);
\end{tikzpicture}
\end{center}
e si definisce questa notazione per gli archi:
$$(p,\alpha)\in\delta(q,a,X)$$
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
	\node[state, initial] (q_0) {$q_0$};
	\node[state] (q_1) [right=of q_0] {$q_1$};
	\path[->]
	(q_0) edge node [align=center] {$a,X/\alpha$} (q_1);
\end{tikzpicture}
\end{center}
\end{esempio}
analizziamo meglio i PDA. Si ha che la \textbf{descrizione istantanea (ID)} di un PDA è una tripla:
$$ID:(q,w,\gamma)$$
con $q\in Q$ stato attuale $w\in\Sigma^*$ input rimanente e $\gamma\in\Gamma^*$ contenuto attuale dello stack.\\
Definiamo ora il concetto di \textbf{mossa in un passo}
dato $P=(Q,\Sigma,\Gamma,\delta,q_0,z_0,F)$ la mossa è una relazione $\stackrel{\vdash}{p}$:
$$(p,\alpha)\in\delta(q,a,X)\,\,allora\,\,\forall w\in\Sigma^*\,\,e\,\, \forall\beta\in\Gamma^*\to (q,aw,X\beta)\vdash(p,w,\alpha\beta$$
e
$$(p,\alpha)\in\delta(q,\varepsilon,X)\,\,allora\,\,\forall w\in\Sigma^*\,\,e\,\, \forall\beta\in\Gamma^*\to (q,w,X\beta)\vdash(p,w,\alpha\beta$$
\newpage
ora possiamo anche definire la relazione con 0 o più mosse 
in forma induttiva $\stackrel{*}{\stackrel{\vdash}{p}}$:
\begin{itemize}
\item \textbf{caso base:} $\forall ID\,\,I, I \stackrel{*}{\vdash} I$
\item \textbf{caso passo:} $I \stackrel{*}{\vdash} J$ se $\exists ID\,\,K$ tale che $ I\vdash K \,\,e\,\, K \stackrel{*}{\vdash} J$
\end{itemize}
vediamo un esempio con un PDA che accetta $ww^R|\,w\in\{0,1\}^*$:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
	\node[state, initial] (q_0) {$q_0$};
	\node[state] (q_1) [right=of q_0] {$q_1$};
	\node[state, accepting] (q_2) [right =of q_1] {$q_2$};
	\path[->]
	(q_0) edge node [align=center] {$\varepsilon,0/0$\\$\varepsilon,1/1$\\$\varepsilon,z_0/z_0$} (q_1)
	      edge [loop below] node [align=center] {$0,z_0/0z_0$\\$1,z_0/1z_0$\\$0,0/00$\\$0,1/01$\\$1,0/10$\\$1,1/11$} ()
	(q_1) edge [loop below] node [align=center] {$0,0/\varepsilon$\\$1,1/\varepsilon$} ()
	      edge  node [align=center] {$\varepsilon,z_0/z_0$} (q_2);
\end{tikzpicture}
\end{center}
e prendiamo la stringa $1111$:\\
\psscalebox{1.0 1.0} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,-2.51)(3.08,2.51)
\rput[bl](0.0,2.29){$q_0,1111,z_0$}
\rput[bl](0.0,1.49){$q_0,111,1z_0$}
\rput[bl](0.0,0.69){$q_0,11,11z_0$}
\rput[bl](0.0,-0.11){$q_0,1,111z_0$}
\rput[bl](0.0,-0.91){$q_0,\varepsilon,1111z_0$}
\rput[bl](0.0,-1.71){$q_1,\varepsilon,1111z_0$}
\rput[bl](0.25,-2.51){$X$}
\rput[bl](3.0,1.49){$(q_1,1111,z_0)\to(q_2,1111,z_0)\to X$}
\rput[bl](3.0,0.69){$(q_1,111,1z_0)\to (q_1,11,z_0)\to(q_2,11,z_0)\to X$}
\rput[bl](3.0,-0.11){$(q_1,11,11z_0)\to(q_1,1,1z_0)\to(q_1,\varepsilon,z_0)\to(q_2,\varepsilon,z_0)\to V$}
\rput[bl](3.0,-0.91){$(q_1,1,111z_0)\to(q_1,\varepsilon,11z_0)\to X$}
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(0.4,2.29)(0.4,1.89)
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(0.4,1.49)(0.4,1.09)
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(0.4,0.69)(0.4,0.29)
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(0.4,-0.11)(0.4,-0.51)
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(0.4,-0.91)(0.4,-1.31)
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(0.4,-1.71)(0.4,-2.11)
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(0.8,1.49)(2.8,1.09)
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(0.8,2.29)(2.8,1.89)
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(0.8,0.69)(2.8,0.29)
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(0.8,-0.11)(2.8,-0.51)
\end{pspicture}
}
chiamiamo \textbf{computazione }una sequenza di mosse, non necessariamente di successo. Si hanno alcune proprietà:
\begin{itemize}
\item se una se una sequenza di ID è lecita per un PDA P allora è lecita anche la sequenza di Id ottenuta concatenando $w\in\Sigma^*$ in ogni ID
\item se una se una sequenza di ID è lecita per un PDA P e resta una coda di input non consumata allora posso rimuovere tale coda in ogni ID e ottenere un'altra sequenza lecita
\item se una se una sequenza di ID è lecita per un PDA P allora  è lecita la sequenza ottenuta aggiungendo $\gamma\in\Gamma^*$ in coda alla terza sequenza di ogni ID
\end{itemize}
del resto però:
$$(q,Xw,\alpha\gamma) \stackrel{*}{\stackrel{\vdash}{p}} (p,Yw,\beta\gamma)\not\to (q,X,\alpha) \stackrel{*}{\vdash}(p,y,\beta),\,\,x,w,y\in\Sigma^*\,\,\alpha,\beta,\gamma\in\Gamma^*$$
per queste proprietà valgono i seguenti teoremi:
\begin{teorema}
per la seconda:
Se $P=(Q,\Sigma,\Gamma,\delta,q_0,z_0,F)$ è un PDA e $(q,Xw,\alpha) \stackrel{*}{\stackrel{\vdash}{p}} (p,Yw,\beta)$ allora vale anche:
$$(q,X,\alpha) \stackrel{*}{\stackrel{\vdash}{p}} (p,Y,\beta)$$
\end{teorema}
\begin{teorema}
per la prima e la terza:
Se $P=(Q,\Sigma,\Gamma,\delta,q_0,z_0,F)$ è un PDA e $(q,X,\alpha) \stackrel{*}{\stackrel{\vdash}{p}} (p,Y,\beta)$ allora:
$$\forall\gamma\in\Gamma^*\,\,\,vale\,\,\,anche\,\,\,(q,Xw,\alpha\gamma) \stackrel{*}{\stackrel{\vdash}{p}} (p,Yw,\beta\gamma)$$
\end{teorema}
Si definiscono due modalità di accettazione per i PDA:
\begin{enumerate}
\item \textbf{per stato finale:} sia $P=(Q,\Sigma,\Gamma,\delta,q_0,z_0,F)$ si ha che:
$$L(P)=\{w\in\Sigma^*|\,(q_0,w,z_0) \stackrel{*}{\stackrel{\vdash}{p}} (q,\varepsilon,\alpha)\}$$
con $q\in F$ e $\forall \alpha\in \Gamma^*$
\item \textbf{per stack vuoto:} sia $P=(Q,\Sigma,\Gamma,\delta,q_0,z_0,F)$ si ha che:
$$N(P)=\{w\in\Sigma^*|\,(q_0,w,z_0) \stackrel{*}{\stackrel{\vdash}{p}} (q,\varepsilon,\varepsilon)\}$$
con $q\in Q$ e in questo caso l'insieme degli stati finali $F$ non ha alcuna influenza
\end{enumerate}
In realtà si ha che la classe di linguaggi accettati dai PDA per stato finale è uguale a quella per stack vuoto, anche se passare da un tipo all'altro di PDA è complesso. SI ha il seguente teorema per la trasformazione:
\begin{teorema}
se $L=N(P_N)$ per un PDA  $P_N=(Q,\Sigma,\Gamma,\delta,q_0,z_0,F)$ allora $\exists \,\,PDA\,\,P_F\,\,\,tale\,\,\,che\,\,\,L=L(P_F)$
\end{teorema}
\begin{proof}
Sia $x_0\in\Gamma$, che indica la fine dello stack di $P_F$. Si ha:
$$\delta(p_0,\varepsilon,x_0)=\{(q_0,z_0x_0\}$$
e:
$$\forall q\in Q,\,\forall a\in\Sigma\cup\{\varepsilon\},,\forall y\in\Sigma:\,\,\delta_F(q,a,y)\mbox{ contiene tutte le coppie di }\delta_N(q,a,y)$$
$$\forall q\in Q,\delta_F(q,\varepsilon,x_0)=\{(P_F,\varepsilon)\}$$
quindi graficamente:
\begin{center}
\psscalebox{1.0 1.0} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,-3.2)(13.6,3.2)
\pscircle[linecolor=black, linewidth=0.04, dimen=outer](2.0,0.0){0.4}
\pscircle[linecolor=black, linewidth=0.04, dimen=outer](5.2,0.0){0.4}
\pscircle[linecolor=black, linewidth=0.04, dimen=outer](7.2,0.0){3.2}
\pscircle[linecolor=black, linewidth=0.04, dimen=outer](8.0,1.2){0.4}
\pscircle[linecolor=black, linewidth=0.04, dimen=outer](8.0,-1.2){0.4}
\pscircle[linecolor=black, linewidth=0.04, dimen=outer](12.8,0.0){0.4}
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(2.4,0.0)(4.8,0.0)
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(0.0,0.0)(1.6,0.0)
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(5.6,0.0)(12.0,0.0)
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(8.4,1.2)(12.0,0.4)
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(8.4,-1.2)(12.0,-0.4)
\rput[bl](0.48,0.3){$start$}
\rput[bl](6.12,1.84){$P_N$}
\rput[bl](1.78,-0.1){$p_0$}
\rput[bl](5.02,-0.16){$q_0$}
\rput[bl](2.42,0.22){$\varepsilon,x_0/z_0x_0$}
\rput[bl](10.8,0.8){$\varepsilon,x_0/\varepsilon$}
\rput[bl](10.8,0.8){$\varepsilon,x_0/\varepsilon$}
\rput[bl](7.44,0.14){$\varepsilon,x_0/\varepsilon$}
\pscircle[linecolor=black, linewidth=0.04, dimen=outer](12.8,0.0){0.8}
\rput[bl](12.58,-0.13){$P_f$}
\rput[bl](10.4,-1.2){$\varepsilon,x_0/\varepsilon$}
\end{pspicture}
}
\end{center}
Bisogna dimostrare che effettivamente $w\in L(P_F)\longleftrightarrow\in N(P_N)$.\\
se $w\in N(P_N)$ $\exists$ una sequenza di $ID\,\,\,(q_0,w,z_0)\stackrel{*}{\stackrel{\vdash}{P_N}}(q,\varepsilon,\varepsilon)$ per un qualche $q\in Q$:
$$(q_0,w,z_0x_0)\stackrel{*}{\stackrel{\vdash}{P_N}}(q,\varepsilon,x_0)$$
inoltre:
$$(q_0,w,z_0x_0)\stackrel{*}{\stackrel{\vdash}{P_F}}(q,\varepsilon,x_0)$$
e quindi:
$$(p_0,w,x_0)\stackrel{\vdash}{P_F}(q_0,w,z_0x_0)\stackrel{*}{\stackrel{\vdash}{P_F}}(q,\varepsilon,x_0)\stackrel{\vdash}{P_F}(P_f,\varepsilon,\varepsilon)$$
solo se togliendo il primo e l'ultimo passo di $P_F$ ripercorro all'indietro quanto scritto sopra.
\end{proof}
\begin{esempio}
trasformazione da accettante per stack vuoto a accettante per stato finale. Siano:
$$\Sigma=\{i,e\}$$
$$P_n=(\{q\}, \{i,e\},\{Z\},\delta_M,q,Z)$$
$$\delta_N(q,i,Z)=\{(q,ZZ)\}$$
$$\delta_N(q,e,Z)=\{(q,\varepsilon)\}$$
quindi:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
	\node[state, initial] (q_0) {$q$};
	\path[->]
	(q_0) edge [loop above] node [align=center] {$i,Z/ZZ$\\$e,Z/\varepsilon$} ();
\end{tikzpicture}
\end{center}
quindi inseriamo una $Z$ quando leggiamo $i$ e ne rimuoviamo una se leggiamo $e$ e si parte con una $Z$ nello stack.\\
Costruisco ora il PDA $P_F$ che accetta lo stesso linguaggio ma per stato finale, introduco lo stato iniziale $p$ e quello  accettante $r$, uso $x_0$ come segnale della fine dello stack:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
	\node[state, initial] (q_0) {$p$};
	\node[state] (q_1) [right=of q_0] {$q$};
	\node[state, accepting] (q_2) [right =of q_1] {$r$} ;
	\path[->]
	(q_0) edge  node [align=center] {$\varepsilon x_0/zx_0$} (q_1)
	(q_1) edge node {$\varepsilon,x_0/\varepsilon$} (q_2)
	      edge [loop above] node [align=center] {$i,Z/ZZ$\\$e,Z/\varepsilon$} ();
\end{tikzpicture}
\end{center}
e si ha formalmente:
$$P_F=(\{p,q,r\}, \{i,e\},\{Z,x_0\},\delta_F,p,x_0,\{r\})$$
con $\delta_F$ che rappresenta le seguenti quattro regole:
\begin{enumerate}
\item $\delta_F(p,\varepsilon,x_0)=\{(q,Zx_0)\}$ regola che fa partire $P_F$ con $x_o$ come segnalatore dello stack
\item $\delta_F(p,i,Z)=\{(q,ZZ)\}$ regola che inserisce $Z$ quando si ha $i$ simulando $P_N$
\item $\delta_F(p,e,Z)=\{(q,Z\varepsilon)\}$ regola che rimuove $Z$ quando si ha $e$ simulando $P_N$
\item $\delta_F(p,e,x_0)=\{(r,\varepsilon)\}$ regola che permette a $P_F$ di accettare quando $P_N$ esaurisce lo stack
\end{enumerate}
\end{esempio}
Si può anche effettuare la trasformazione inversa:
\begin{teorema}
Sia $P_F=(Q,\Sigma,\Gamma,\delta_f,q_0,Z_0,F)$.\\
 Si aggiunge una transizione $\varepsilon$  a un nuovo stato $p$ da ogni accettante di $P_F$. quando si ha $p$ $P_N$ svuota lo stack senza consumare input. Quindi se $P:F$ entra in uno stato accettante dopo aver consumato l'input $w$, $P_N$ svuota lo stack dopo aver consumato $w$. Per evitare che si svuoti lo stack per una stringa non accettata uso $x_0$ per indicare il fondo dello stack. Il nuovo $P_N$ parte da $p_0$ che ha il solo scopo di inserire il simbolo iniziale di $P_F$ e passare al suo stato iniziale. Si ottiene quindi:
\begin{center}
 \psscalebox{1.0 1.0} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,-3.2)(14.91,3.2)
\pscircle[linecolor=black, linewidth=0.04, dimen=outer](2.0,0.0){0.4}
\pscircle[linecolor=black, linewidth=0.04, dimen=outer](5.2,0.0){0.4}
\pscircle[linecolor=black, linewidth=0.04, dimen=outer](7.2,0.0){3.2}
\pscircle[linecolor=black, linewidth=0.04, dimen=outer](8.0,1.2){0.4}
\pscircle[linecolor=black, linewidth=0.04, dimen=outer](8.0,-1.2){0.4}
\pscircle[linecolor=black, linewidth=0.04, dimen=outer](12.8,0.0){0.4}
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(2.4,0.0)(4.8,0.0)
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(0.0,0.0)(1.6,0.0)
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(8.4,1.2)(12.38,0.42)
\psline[linecolor=black, linewidth=0.04, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(8.4,-1.2)(12.4,-0.38)
\rput[bl](0.48,0.3){$start$}
\rput[bl](6.06,1.88){$P_F$}
\rput[bl](1.78,-0.1){$p_0$}
\rput[bl](5.02,-0.16){$q_0$}
\rput[bl](2.42,0.22){$\varepsilon,x_0/z_0x_0$}
\rput[bl](10.8,0.8){$\varepsilon,x_0/\varepsilon$}
\rput[bl](10.8,0.8){$\varepsilon,x_0/\varepsilon$}
\rput[bl](12.68,-0.08){$p$}
\rput[bl](10.4,-1.2){$\varepsilon,x_0/\varepsilon$}
\pscircle[linecolor=black, linewidth=0.04, dimen=outer](8.0,1.18){0.32}
\pscircle[linecolor=black, linewidth=0.04, dimen=outer](8.0,-1.22){0.32}
\rput{-162.98488}(25.685106,3.4421315){\psarc[linecolor=black, linewidth=0.04, dimen=outer, arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.0]{->}(13.1,-0.2){0.46}{0.0}{260.0}}
\rput[bl](10.8,0.8){$\varepsilon,x_0/\varepsilon$}
\rput[bl](10.8,0.8){$\varepsilon,x_0/\varepsilon$}
\rput[bl](13.92,-0.38){$\varepsilon,x_0/\varepsilon$}
\end{pspicture}
}
\end{center}
e si ha formalmente:
$$P_F=(Q\cup\{p_0,p\}, \Sigma,\Gamma\cup\{x_0\},\delta_N,p_0,x_0)$$
dove $\delta_N$ è così definita:
\begin{enumerate}
\item $\delta_N(p_0,\varepsilon,x_0)=\{(q_0,Z_0x_0)\}$ inserisce il simbolo iniziale di $P_F$ nello stack e va allo stato iniziale di $P_F$
\item $\forall q\in Q$ ogni simbolo di input $a\in\Sigma$, compreso l'input vuoto, e $\forall y\in \Gamma$, $\delta_N(q,a,y)$  contiene tutte le coppie di $\delta_F(q,a,y)$. Quindi $P_N$ simula $P_F$
\item per tutti gli stati accettanti $q\in F$ e i simboli di stack $y\in\Gamma$, compreso $x_0$, si ha che $\delta_N(q,\varepsilon,y)$ contiene $(p,\varepsilon)$, quindi ogni volta che $P_F$ accetta $P_N$ inizia scaricare lo stack senza consumare ulteriori input
\item per tutti  i simboli di stack $y\in\Gamma$, compreso $x_0$, si ha che $\delta_N(q,\varepsilon,y)=\{(p,\varepsilon)\}$, quindi giunti allo stato $p$, ovvero quando $P_F$ ha accettato, $P_N$ elimina ogni simbolo nel suo stack fino a svuotarlo
\end{enumerate}
inoltre formalmente voglio dimostrare che:
$$w\in L(P_F)\to w\in N(P_N)$$
e quindi ho le seguenti mosse:
$$(q_0,w,z_0)\stackrel{*}{\stackrel{\vdash}{P_F}}(q,\varepsilon,\alpha)\,\,q\in F,\,\,\alpha\in\Gamma^*$$
$$(p_o,w,x_0)\vdash(q_0,w,z_0x_0)\stackrel{*}{\stackrel{\vdash}{P_N}}(q,\varepsilon,\alpha,x_0)\stackrel{*}{\stackrel{\vdash}{P_N}}(p,\varepsilon,\varepsilon)$$
\end{teorema}
\begin{esempio}
si ha una CFG $G=(\{i,e\},\{a,b,0,1,*,+,(,)\},P,E)$
con:
$$P:I\to a|b|Ia|Ib|I0|I1$$
$$\,\,E\to E+E|E*E|(E)$$
si ha il PDA $P_G=(\{q\},\Sigma,\Sigma\cup\{i,e\},\delta,q,E)$:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
	\node[state, initial] (q_0) {$q$};
	\path[->]
	(q_0) edge [loop above] node [align=center] {$\mbox{ }$} ();
\end{tikzpicture}
\end{center}
si ha quindi:
$$\delta(q,\varepsilon, i)=\{(q,a),(q,b),(q,Ia),(q,Ib),(q,I0),(q,I1)\}$$
$$\delta(q,\varepsilon, E)=\{(q,I),(q,E+E),(q,E*E),(q,I(E))\}$$
$$\delta(q,a,a)=\{(q,\varepsilon)\}$$
$$\delta(q,b,b)=\{(q,\varepsilon)\}$$
$$\cdots=\{(q,\varepsilon)\}$$
quindi si ha:
$$E\to E+E\to i+E\to a+(E)\to a+(i)\to a+(i0)\to a+(b0)$$
$$(q, a+(b0),E)\vdash (q, a+(b0),E+E)\vdash (q, a+(b0),i+E)\vdash (q, a+(b0),a+E)$$
$$\vdash (q, +(b0),+E)\vdash (q, (b0),E)\vdash (q, (b0),(E))\vdash (q, b0),E))$$
$$\vdash (q, b0),i))\vdash (q, b0),i0))\vdash (q, b0),b0)\vdash (q, 0),0))$$
$$\vdash (q, ),))\vdash (q, \varepsilon,\varepsilon)$$
\end{esempio}
questo esempio è generalizzabile ad ogni CFG:

$$\exists\,\, PDA\,\,Q=(\{q\},T,V\cup T,\delta,q,S)\mbox{ tale che }N(Q)=L(G)$$
$$\forall A\in V\,\,\delta(q,\varepsilon,A)=\{(q,\beta)|\,A\to B\mbox{ e' una produzione di G}\}$$
$$\forall a\in T\,\,\delta(q,a,a)=\{(a,\varepsilon)\}$$
\begin{teorema}
sia $G=(V,T,P,S)$ una CFG:
\end{teorema}
Questo dimostra che ogni CFL può essere accettato da un PDA accettante per stack vuoto. Per il teorema visto in precedenza, posso sempre costruire un altro PDA accettante per stati finale. I PDA accettano tutti e soli i linguaggi CF. Mostrare che accettano solo linguaggi di tipo 2 è complicato.\\
Un tipo di PDA interessante, soprattutto per i parse, è il PDA deterministico, il \textbf{DPDA}.\\
Un PDA $P=(Q,\Sigma,\Gamma,\delta,q_0,z_0,F)$ è deterministico se:
\begin{enumerate}
\item $|\delta(q,a,x)|\leq 1$ $\forall q\in Q,\forall a\in\Sigma\cup\{\varepsilon\},\forall x\in \Gamma$
\item se $|\delta(q,a,x)|\neq 0$ per qualche $a\in \Sigma$ allora $|\delta(q,\varepsilon,x)|=0$
\end{enumerate}
\begin{esempio}
abbiamo il linguaggio $L_{wcw^R}=\{wcw^R|\,w\in\{0,1\}^*\}$\\
Gli automi a pila deterministici non riconosco tutti i CFL, ma solo una classe strettamente più piccola. Ad esempio non potrebbero riconoscere il linguaggio delle palindrome senza "il segnalibro" c. SI ha quindi:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
	\node[state, initial] (q_0) {$q_0$};
	\node[state] (q_1) [right=of q_0] {$q_1$};
	\node[state, accepting] (q_2) [right =of q_1] {$q_2$} ;
	\path[->]
	(q_0) edge [loop above] node [align=center] {$0,z_0/0z_0$\\$1,z_0/1z_0$\\$0,0/00$\\$0,1/01$\\$1,0/10$\\$1,1/11$} ()
	      edge node [align=center] {$c,z_0/0z_0$\\$c,0/0$\\$c,1/1$} (q_1)
	(q_1) edge node {$\varepsilon,z_0/z_0$} (q_2)
	      edge [loop above] node [align=center] {$0,0/\varepsilon$\\$1,1/\varepsilon$} ();
\end{tikzpicture}
\end{center}
quindi:
\begin{center}
\psscalebox{1.0 1.0} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,-2.0)(7.6,2.0)
\psframe[linecolor=black, linewidth=0.04, dimen=outer](7.6,2.0)(0.0,-2.0)
\psframe[linecolor=black, linewidth=0.04, dimen=outer](4.8,0.8)(0.8,-1.2)
\psframe[linecolor=black, linewidth=0.04, dimen=outer](2.4,0.0)(1.2,-0.8)
\rput[bl](0.4,1.6){CFL}
\rput[bl](1.46,-0.52){REG}
\rput[bl](3.68,0.28){DPDA}
\rput[bl](3.18,1.18){PDA per stato finale}
\rput[bl](3.2,1.6){PDA per stack vuoto}
\rput[bl](3.42,-0.86){$Lwcw^R$}
\rput[bl](5.96,-1.5){$Lww^R$}
\end{pspicture}
}
\end{center}
\end{esempio}
si ha infatti il seguente teorema:
\begin{teorema}
$L\in REG\to\exists PDA\,\,P\,\,tale\,\,che\,\,L=L(P)$
\end{teorema}
\begin{proof}
$$L\in REG\to\exists DFA\,\,A=(Q,\Sigma,\delta_A,q_0,F)\,\,tale\,\,che\,\, L=L(A)$$
costruisco il DPDA $P=(Q,\Sigma,\{z_0\},\delta_p,q_0,z_0,F)$ con:
$$\delta_p(q,a,z_0)=\{p,z_0\}\,\,\forall p,q\in Q\,\,tali\,\,che\,\,\delta_A(q,a)=0$$
vale:
$$(q_0,w,z_0)\stackrel{A}{\stackrel{\vdash}{P}}(p,\varepsilon,z_0)\longleftrightarrow \stackrel{\wedge}{\delta_A}(q_0,w)=p$$
\end{proof}
si ha inoltre il seguente teorema:
\begin{teorema}
$L$ è $N(P)$ per un DPDA $P$ sse $L$ è $L(P^{'})$ per un DPDA $P^{'}$ e $L$ ha le proprietà di prefisso \textbf{prefix-free}
\end{teorema}
definiamo così la proprietà di prefisso:
$$\not\exists x,y\in L\,\,tali\,\,che\,\,x\neq y\,\,e\,\, x \mbox{ è prefisso di } y$$
per esempio $L=\{0\}^0=\{\varepsilon,0,00,000,...\}$ non ha la proprietà di prefisso. Osserviamo che se la stringa vuota appartiene al linguaggio, tale stringa è prefissa di tutte le altre e quindi il linguaggio non può avere la proprietà di prefisso. Affermiamo che L è regolare, quindi è accettato da un DPDA per stati finali ma non da uno per stack vuoto. Completiamo il diagramma precedente sulle classi di
linguaggi:
\begin{center}


\psscalebox{1.0 1.0} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,-2.0)(7.6,2.0)
\psframe[linecolor=black, linewidth=0.04, dimen=outer](7.6,2.0)(0.0,-2.0)
\psframe[linecolor=black, linewidth=0.04, dimen=outer](5.0,0.76)(0.7,-1.56)
\psframe[linecolor=black, linewidth=0.04, dimen=outer](2.38,-0.02)(0.92,-0.82)
\rput[bl](0.4,1.6){CFL}
\rput[bl](1.066,-0.54){REG}
\rput[bl](2.76,0.36){DPDA}
\rput[bl](3.18,1.18){PDA per stato finale}
\rput[bl](3.2,1.6){PDA per stack vuoto}
\rput[bl](5.96,-1.5){$Lww^R$}
\psframe[linecolor=black, linewidth=0.04, dimen=outer](4.52,0.28)(2.14,-1.12)
\rput[bl](2.45,-0.56){$N(DPDA)$}
\end{pspicture}
}

\end{center}
SI ha che $L_{wcw^R}$ gode della proprietà di prefisso:
$$y=wcw^R\in L\,\, Se\,\,x\neq y,\mbox{ prefisso di } y,x\not\in L$$
tornando alle grammatiche si hanno ora due teoremi:
\begin{teorema}
se $L=N(P)$ per un DPDA P, allora L ha una CFG non ambigua
\end{teorema}
\begin{teorema}
se $L=L(P)$ per un DPDA P, allora L ha una CFG non ambigua
\end{teorema}
dimostriamo il secondo:
\begin{proof}
$L=L(P)$ per un DPDA P, costruiamo $L^{'}=L$, quindi $L^{'}$ ha la proprietà di prefisso. Esiste quindi un DPDA $P^{'}$ tale che $L^{'}N(P)$, esiste quindi per il teorema sopra una CFG $G^{'}$ tale che $L(G^{'})=L^{'}$ che non è ambigua.\\
Costruiamo $G$ per $L$ con le stesse produzioni di $G^{'}$ più $\$\to\varepsilon$, applicata solo all'ultimo passo.
\end{proof}
Vogliamo scoprire se è vero il viceversa: per ogni L che ha una CFG non ambigua è vero che L è
accettato da un DPDA? No, mostriamo infatti un controesempio:\\
$S\to 0S0|1S1|\varepsilon$ produce $L_{ww^R}$ che non è accettato da alcun PDA
\subsection{Esercizi}
\begin{esercizio}
costruire un PDA per $L=\{0^n\^n|\,n\geq 1\}$:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
	\node[state, initial] (q_0) {$q_0$};
	\node[state] (q_1) [right=of q_0] {$q_1$};
	\node[state, accepting] (q_2) [right =of q_1] {$q_2$} ;
	\path[->]
	(q_0) edge [loop above] node [align=center] {$0,0/00$\\$0,z_0/0z_0$} ()
	      edge node [align=center] {$1,0/\varepsilon$} (q_1)
	(q_1) edge node {$\varepsilon,z_0/\varepsilon$} (q_2)
	      edge [loop above] node [align=center] {$1,0/\varepsilon$} ();
\end{tikzpicture}
\end{center}
Osserviamo che questo è un DPDA e L è accettato sia per stato finale che per stack vuoto.
Osserviamo anche che L ha la proprietà di prefisso:
$$y=0^n1^n\in L,x\neq y$$
e $x$ è prefissa di y e quindi x ha un numero di 0 diverso da quelli di 1 e quindi $x\not\in L$
\end{esercizio}

\begin{esercizio}
costruire un PDA per $L=\{0^n\^n|\,n\geq 0\}$:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
	\node[state, initial] (q_0) {$q_0$};
	\node[state] (q_1) [right=of q_0] {$q_1$};
	\node[state, accepting] (q_2) [right =of q_1] {$q_2$} ;
	\path[->]
	(q_0) edge [loop above] node [align=center] {$0,0/00$\\$0,z_0/0z_0$} ()
	      edge node [align=center] {$1,0/\varepsilon$} (q_1)
	       edge [bend left = 25] node {$\varepsilon,z_0/\varepsilon$} (q_2)
	(q_1) edge node {$\varepsilon,z_0/\varepsilon$} (q_2)
	      edge [loop below] node [align=center] {$1,0/\varepsilon$} ();
\end{tikzpicture}
\end{center}
Ora la stringa vuota appartiene al linguaggio. Il linguaggio non ha la proprietà del prefisso. Si può dimostrare che non esiste un DPDA per L.
\end{esercizio}
\begin{esercizio}
considero il linguaggio generato da $B\to (BB)|(B)|()$.\\
Il linguaggio ha la proprietà di prefisso perché (BB). Se fosse B -> BB allora non lo avrebbe, perché potremmo costruire le stringhe () e ()().
\\Abbiamo quindi il DPDA per stato finale:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
	\node[state, initial] (q_0) {$q_0$};
	\node[state] (q_1) [right=of q_0] {$q_1$};
	\node[state, accepting] (q_2) [right =of q_1] {$q_2$} ;
	\path[->]
	(q_0) edge [loop above] node [align=center] {$(,z_0/(z_0$\\$(,(/(($} ()
	      edge [bend left = 25] node [align=center] {$),(/\varepsilon$} (q_1)
	       
	(q_1) edge node {$\varepsilon,z_0/\varepsilon$} (q_2)
		  edge [bend left = 25] node {$(,(/(($} (q_0)
	      edge [loop above] node [align=center] {$),(/\varepsilon$} ();
\end{tikzpicture}
\end{center}
volendo accettare solo per stack vuoto:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
	\node[state, initial] (q_0) {$q_0$};
	\node[state] (q_1) [right=of q_0] {$q_1$};
	\path[->]
	(q_0) edge [loop above] node [align=center] {$(,z_0/(z_0$\\$(,(/(($} ()
	      edge [bend left = 25] node [align=center] {$),(/\varepsilon$} (q_1)
	       
	(q_1) edge [bend left = 25] node {$(,(/(($} (q_0)
	      edge [loop above] node [align=center] {$),(/\varepsilon$ \\ $\varepsilon,z_0/\varepsilon$} ();
\end{tikzpicture}
\end{center}
\end{esercizio}
\begin{esercizio}
Si ha $B\to BB|(B)|()$. La stringa vuota non appartiene al linguaggio ma L non ha la proprietà del prefisso (come abbiamo
mostrato nell'esercizio precedente). Possiamo quindi realizzare solo un DPDA per stato finale:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
	\node[state, initial] (q_0) {$q_0$};
	\node[state] (q_1) [right=of q_0] {$q_1$};
	\node[state] (q_2) [right =of q_1] {$q_2$};
	\node[state,accepting] (q_3) [below right =of q_1] {$q_3$};
	\path[->]
	(q_0) edge node [align=center] {$(,z_0/(z_0$} (q_1)
	       
	(q_1) edge [bend left = 25] node {$),(/\varepsilon$} (q_2)
	      edge [loop above] node [align=center] {$(,(/(($} ()
	(q_2) edge [bend left = 25] node {$(,(/(($} (q_1)
	      edge [loop above] node [align=center] {$),(/\varepsilon$} () 
	      edge node {$\varepsilon,z_0/z_0$} (q_3)   
	      (q_3) edge node {$(,z_0/(z_0$} (q_1)  ;
\end{tikzpicture}
\end{center}
\end{esercizio}
\begin{esercizio}
Si ha $B\to BB|(B)|\varepsilon$ ho un DPDA per stato finale perché L non ha la proprietà del prefisso:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
	\node[state, initial,accepting] (q_0) {$q_0$};
	\node[state] (q_1) [right=of q_0] {$q_1$};
	\node[state] (q_2) [right =of q_1] {$q_2$};
	
	\path[->]
	(q_0) edge node [align=center] {$(,z_0/(z_0$} (q_1)
	       
	(q_1) edge [bend left = 25] node {$),(/\varepsilon$} (q_2)
	      edge [loop above] node [align=center] {$(,(/(($} ()
	(q_2) edge [bend left = 25] node {$(,(/(($} (q_1)
	      edge [loop above] node [align=center] {$),(/\varepsilon$} () 
	      edge [bend left = 65] node {$\varepsilon,z_0/z_0$} (q_0);
\end{tikzpicture}
\end{center}
\end{esercizio}
\begin{esercizio}
sia $L=\{q\in\{a,b\}^*| numero\,\,uguale\,\,di\,\,a\,\,e\,\,b\}$ DPDA per stato finale (L non ha la proprietà di prefisso):
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
	\node[state, initial,accepting] (q_0) {$q_0$};
	\node[state] (q_1) [right=of q_0] {$q_1$};
	\path[->]
	(q_0) edge [bend left=25] node [align=center] {$b,z_0/bz_0$\\$a,z_0/az_0$} (q_1)
	       
	(q_1) edge [bend left = 25] node {$\varepsilon,z_0/z_0$} (q_0)
	      edge [loop above] node [align=center] {$a,a/aa$\\$b,b/bb$\\$a,b/\varepsilon$ \\$b,a/\varepsilon$} ()
	;
\end{tikzpicture}
\end{center}
\end{esercizio}
\newpage
\begin{esercizio}
sia dato il CFL $L=\{a^ncb^n|n\geq 0\}$\\
è generato da :
$$G=(\{S\},\{a,b,c\},P,S)$$
$$S\to aSb|c$$
si ha il seguente automa non deterministico:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
	\node[state, initial,accepting] (q_0) {$q_0$};
	\path[->]
	(q_0) edge [loop above] node [align=center] {$\varepsilon,S/aSb$\\$\varepsilon,S/c$\\$a,a/\varepsilon$\\$b,b/\varepsilon$\\$c,c/\varepsilon$} ();
\end{tikzpicture}
\end{center}
con:
$$\delta(q,\varepsilon,S)=\{(q,aSb),(q,c)\}$$
$$\delta(q,a,a)=\{(q,\varepsilon)\}$$
$$\delta(q,b,b)=\{(q,\varepsilon)\}$$
$$\delta(q,c,c)=\{(q,\varepsilon)\}$$
mostro la derivazione per n=3, aaacbbb e il comportamento dell'automa:
$$(q,aaacbbb,S)\vdash(q,aaacbbb,aSb)\vdash(q,aacbb,Sb)\vdash(q,aacbb,aSb)$$
$$\vdash(q,acbbb,Sbb)\vdash(q,acbbb,aSbbb)\vdash(q,cbbb,Sbbbb)\vdash(q,cbbb,cbbb)$$
$$\vdash(q,bbb,bbb)\vdash(q,bb,bb)\vdash(q,b,b)\vdash(q,\varepsilon,\varepsilon)\to \,\, accetta$$
si ha che vale la proprietà del prefisso e si ha il seguente DPDA:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
	\node[state, initial,accepting] (q_0) {$q_0$};
	\node[state] (q_1) [right=of q_0] {$q_1$};
	\node[state] (q_2) [right =of q_1] {$q_2$};
	\path[->]
	(q_0) edge node [align=center] {$c,z_0/cz_0$\\$c,a/a$} (q_1)
	      edge [loop above] node [align=center] {$a,z_0/az_0$\\$a,a/aa$} () 
	(q_1) edge  node {$\varepsilon,z_0/z_0$} (q_2)
	      edge [loop above] node [align=center] {$b,a/\varepsilon$} ();
\end{tikzpicture}
\end{center}
\end{esercizio}
\newpage
\section{Macchine di Turing}
Nascono in risposta al problema di Hilbert, che si chiedeva se esiste un algoritmo per dimostrare teoremi. Non ci sono comunque funzioni non calcolabili con le macchine di Turing:
$$f:\mathbb{N}\to\{0,1\}\,\,s^{|\mathbb{N}|>\mathbb{N}$$
Siamo interessati a studiare la calcolabilità (computabilità).
Esiste un programma che calcola una certa funzione? Se non esiste, $f$ è indecidibile. Se sì, in quanto tempo è calcolabile (complessità computazionale), quante mosse e quante celle del nastro sono necessarie?\\
vediamo due esempi
\end{document}